<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Audio Visualizer v3 – 草/花/鳥/蝶/芋虫 + 雨粒/☆ + 録画</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.sound.min.js"></script>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; padding:0; background:#090a10; color:#eef2ff; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "Noto Sans JP", sans-serif; }
    #ui {
      position: fixed; left: 16px; top: 16px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
      background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
      padding: 8px 10px; border-radius: 12px; backdrop-filter: blur(6px);
      max-width: min(92vw, 760px);
    }
    #ui button, #ui label, #ui input, #ui select {
      appearance: none; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.08);
      color: #eef2ff; padding: 6px 10px; border-radius: 10px; cursor: pointer; font-size: 13px;
    }
    #ui input[type="range"] { width: 120px; cursor: ew-resize; }
    #ui .group { display:flex; gap:8px; align-items:center; }
    #ui .muted { opacity:.8; font-size:12px; border:none; background:transparent; padding:0; cursor:default; }
    #file { display:none; }
    #legend {
      position: fixed; right: 16px; top: 16px; font-size: 12px; line-height: 1.45;
      color: #cfd7ff; opacity: .9; background: rgba(16,16,24,.35); border: 1px solid rgba(255,255,255,.08);
      padding: 8px 10px; border-radius: 10px; max-width: 42ch;
    }
    #legend.hidden { display:none; }
    #reopen { position: fixed; left: 16px; top: 16px; display:none; }
    #reopen button { appearance:none; border:1px solid rgba(255,255,255,.2); background:rgba(255,255,255,.08); color:#eef2ff; padding:8px 10px; border-radius:12px; }
    a { color: #9ec5ff; }
  </style>
</head>
<body>
  <div id="ui">
    <div class="group">
      <label for="file">音声ファイル</label><input id="file" type="file" accept="audio/*"/>
      <button id="mic">マイク</button>
      <button id="play">再生</button>
      <button id="pause">一時停止</button>
      <span id="status" class="muted">準備中</span>
    </div>
    <div class="group">
      <label><input type="checkbox" id="levelMode" checked/> 音量依存</label>
      <label>🐦出現倍率 <input type="range" id="birdScale" min="0.5" max="3.0" step="0.1" value="1.8"/></label>
      <label>ノイズ感度 <input type="range" id="noiseSens" min="0.5" max="1.0" step="0.01" value="0.70"/></label>
    </div>
    <div class="group">
      <button id="toggleLegend">説明の表示/非表示</button>
      <button id="collapseUI">UI最小化</button>
    </div>
    <div class="group">
      <button id="recStart">● 録画開始</button>
      <button id="recStop" disabled>■ 停止</button>
      <a id="download" class="muted" href="#" download="visualizer.webm"></a>
    </div>
  </div>
  <div id="reopen"><button id="reopenBtn">⚙️</button></div>

  <div id="legend" class="hidden">
    <div>帯域は一般的な楽曲向けに調整、位置はサブバンド内のログ周波数分布で全幅にマップ。</div>
    <hr/>
    <div>💧 40–180Hz: 雨粒（大）</div>
    <div>🌱 180–500Hz: 草（量1/10）</div>
    <div>🌼 500–1000Hz: 花</div>
    <div>🦋 1–3kHz: ちょうちょ</div>
    <div>🐦 3–6kHz: 鳥（白線に着地）</div>
    <div>⭐ 6–12kHz: 星（大）</div>
    <div>⭐（小） 短いピーク: 星（小）</div>
    <div>⋯ スペクトル平坦度: 空の塵</div>
  </div>

  <script>
    // ======= Audio =======
    let fft, amp, mic, sound, usingMic = false, fileLoaded = false;
    let peak;
    let lastActiveMillis = 0;
    let silenceFade = 0;

    // ======= Visual State =======
    const plants = [], birds = [], butterflies = [], caterpillars = [];
    const stars = [], bigStars = [], drops = [], dust = [];
    let baselineY;

    const MAX_COUNTS = { plants: 220, birds: 14, butterflies: 18, caterpillars: 2, stars: 180, bigStars: 50, drops: 50, dust: 240 };
    const COOLDOWN   = { bird: 200, star: 50, bigStar: 70, drop: 70, caterpillar: 6000 };
    let lastSpawn    = { bird: -9e9, star: -9e9, bigStar: -9e9, drop: -9e9, caterpillar: -9e9 };

    // Toggles / sliders
    let levelModeEl, birdScaleEl, noiseSensEl;
    let noiseStart = 0.70;

    // EMA for volume-insensitive mode
    const ema = { bass: 110, grass: 120, flower: 120, bfly: 120, bird: 120, high: 120 };
    const emaAlpha = 0.05;

    // ======= Recording =======
    let recorder, recordedChunks = [], recording = false, combinedStream;

    function setup() {
      createCanvas(window.innerWidth, window.innerHeight);
      pixelDensity(window.devicePixelRatio || 1);
      baselineY = height * 0.85;

      fft = new p5.FFT(0.8, 1024);
      amp = new p5.Amplitude();
      peak = new p5.PeakDetect(20, 12000, 0.17, 20);

      const fileInput = document.getElementById('file');
      const micBtn = document.getElementById('mic');
      const playBtn = document.getElementById('play');
      const pauseBtn = document.getElementById('pause');
      levelModeEl = document.getElementById('levelMode');
      birdScaleEl = document.getElementById('birdScale');
      noiseSensEl = document.getElementById('noiseSens');
      document.getElementById('toggleLegend').addEventListener('click', ()=>{
        document.getElementById('legend').classList.toggle('hidden');
      });
      document.getElementById('collapseUI').addEventListener('click', ()=>{
        document.getElementById('ui').style.display = 'none';
        document.getElementById('reopen').style.display = 'block';
      });
      document.getElementById('reopenBtn').addEventListener('click', ()=>{
        document.getElementById('ui').style.display = 'flex';
        document.getElementById('reopen').style.display = 'none';
      });
      noiseSensEl.addEventListener('input', ()=>{ noiseStart = parseFloat(noiseSensEl.value); });

      fileInput.addEventListener('change', async (e) => {
        await userStartAudio();
        stopAllAudio();
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        sound = loadSound(url, () => {
          fileLoaded = true;
          usingMic = false;
          amp.setInput(sound);
          fft.setInput(sound);
          document.getElementById('status').textContent = 'ファイル読み込み完了';
          sound.onended(() => { lastActiveMillis = millis() - 5000; });
        }, () => {
          document.getElementById('status').textContent = '読み込み失敗';
        });
      });

      micBtn.addEventListener('click', async () => {
        await userStartAudio();
        stopAllAudio();
        mic = new p5.AudioIn();
        mic.start(() => {
          usingMic = true; fileLoaded = false;
          amp.setInput(mic); fft.setInput(mic);
          document.getElementById('status').textContent = 'マイク入力中';
        }, () => { document.getElementById('status').textContent = 'マイク許可エラー'; });
      });

      playBtn.addEventListener('click', async () => {
        await userStartAudio();
        if (sound && fileLoaded) {
          if (!sound.isPlaying()) sound.play();
          document.getElementById('status').textContent = '再生中';
        }
      });
      pauseBtn.addEventListener('click', () => {
        if (sound && sound.isPlaying()) {
          sound.pause();
          document.getElementById('status').textContent = '一時停止';
        }
      });

      // Recording
      document.getElementById('recStart').addEventListener('click', startRecording);
      document.getElementById('recStop').addEventListener('click', stopRecording);
    }

    function windowResized() {
      resizeCanvas(window.innerWidth, window.innerHeight);
      baselineY = height * 0.85;
    }

    function stopAllAudio() {
      if (sound) { try { sound.stop(); } catch(e){} }
      if (mic) { try { mic.stop(); } catch(e){} }
    }

    // Band energy helper with optional volume normalization
    function normEnergy(name, e) {
      ema[name] = lerp(ema[name], e, emaAlpha);
      // Ratio -> scale around 128
      const r = e / (ema[name] + 1e-3);
      return constrain(128 * r, 0, 255);
    }

    // ======= Recording helpers =======
    async function startRecording() {
      if (recording) return;
      const canvasEl = document.querySelector('canvas');
      const fps = 60;
      const videoStream = canvasEl.captureStream(fps);

      // Try to capture audio
      const tracks = [...videoStream.getTracks()];
      const ctx = getAudioContext();
      let dest;
      try {
        dest = ctx.createMediaStreamDestination();
        // Try to connect p5 master output (works in many browsers/p5 versions)
        if (window.p5 && window.p5.prototype && window.p5.prototype.soundFormats) {
          if (window.p5.soundOut && (window.p5.soundOut.output || window.p5.soundOut.gain)) {
            (window.p5.soundOut.output || window.p5.soundOut.gain).connect(dest);
          }
        }
      } catch(e) { /* ignore */ }

      // Add mic track if usingMic
      if (usingMic && mic && mic.stream) {
        const micTracks = mic.stream.getAudioTracks();
        micTracks.forEach(t => tracks.push(t));
      } else if (dest && dest.stream) {
        const aTracks = dest.stream.getAudioTracks();
        aTracks.forEach(t => tracks.push(t));
      }

      combinedStream = new MediaStream(tracks);
      const mime = MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus') ? 'video/webm;codecs=vp9,opus'
                  : MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus') ? 'video/webm;codecs=vp8,opus'
                  : 'video/webm';
      try {
        recorder = new MediaRecorder(combinedStream, { mimeType: mime, videoBitsPerSecond: 6_000_000 });
      } catch(e) {
        recorder = new MediaRecorder(combinedStream);
      }
      recordedChunks = [];
      recorder.ondataavailable = (e)=>{ if (e.data && e.data.size > 0) recordedChunks.push(e.data); };
      recorder.onstop = ()=>{
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.getElementById('download');
        a.href = url; a.textContent = '録画をダウンロード（webm）';
        a.download = 'visualizer_' + new Date().toISOString().replaceAll(':','-') + '.webm';
      };
      recorder.start();
      recording = true;
      document.getElementById('recStart').disabled = true;
      document.getElementById('recStop').disabled  = false;
      document.getElementById('download').textContent = '';
    }

    function stopRecording() {
      if (!recording) return;
      recorder.stop();
      recording = false;
      document.getElementById('recStart').disabled = false;
      document.getElementById('recStop').disabled  = true;
    }

    // ======= Draw Loop =======
    function draw() {
      background(9, 10, 16, 255);

      const spectrum = fft.analyze();
      const level = amp.getLevel();
      peak.update(fft);

      const active = level > 0.01 || (sound && sound.isPlaying());
      if (active) lastActiveMillis = millis();

      const silentFor = millis() - lastActiveMillis;
      if (silentFor > 1200) { silenceFade = min(1, silenceFade + 0.02); }
      else { silenceFade = max(0, silenceFade - 0.03); }

      // Baseline
      stroke(255); strokeWeight(3); line(0, baselineY, width, baselineY); noStroke();

      // Bands
      let e_bass   = fft.getEnergy(40, 180);
      let e_grass  = fft.getEnergy(180, 500);
      let e_flower = fft.getEnergy(500, 1000);
      let e_bfly   = fft.getEnergy(1000, 3000);
      let e_bird   = fft.getEnergy(3000, 6000);
      let e_high   = fft.getEnergy(6000, 12000);

      if (!levelModeEl.checked) {
        e_bass   = normEnergy('bass', e_bass);
        e_grass  = normEnergy('grass', e_grass);
        e_flower = normEnergy('flower', e_flower);
        e_bfly   = normEnergy('bfly', e_bfly);
        e_bird   = normEnergy('bird', e_bird);
        e_high   = normEnergy('high', e_high);
      }

      // Spectral flatness proxy via entropy
      let sum = 0; for (let i=0;i<spectrum.length;i++) sum += spectrum[i] + 1e-6;
      let entropy = 0; for (let i=0;i<spectrum.length;i++){ const p=(spectrum[i]+1e-6)/sum; entropy += -p*Math.log(p); }
      entropy = entropy / Math.log(spectrum.length);
      const noiseIndex = entropy;

      // ===== Spawns =====
      const birdScale = parseFloat(birdScaleEl.value || '1.0');

      // Grass (1/10 rate)
      if (!Number.isNaN(e_grass) && e_grass > 120 && plants.length < MAX_COUNTS.plants) {
        const base = floor(map(e_grass, 120, 255, 1, 5, true));
        const count = max(0, floor(base * 0.1)); // 1/10
        for (let i=0;i<count;i++) { plants.push(new Plant(pickXFromBand(180, 500, spectrum), 'grass')); }
      }

      // Flowers
      if (!Number.isNaN(e_flower) && e_flower > 120 && plants.length < MAX_COUNTS.plants) {
        const count = floor(map(e_flower, 120, 255, 1, 4, true));
        for (let i=0;i<count;i++) { plants.push(new Plant(pickXFromBand(500, 1000, spectrum), 'flower')); }
      }

      // Butterflies
      if (!Number.isNaN(e_bfly) && e_bfly > 120 && butterflies.length < MAX_COUNTS.butterflies && random()<0.7) {
        const n = floor(map(e_bfly, 120, 255, 1, 3, true));
        for (let i=0;i<n;i++) butterflies.push(new Butterfly(pickXFromBand(1000, 3000, spectrum)));
      }

      // Birds (more frequent + scale)
      if (!Number.isNaN(e_bird) && e_bird > 130 && millis() - lastSpawn.bird > COOLDOWN.bird && birds.length < MAX_COUNTS.birds) {
        const n = max(1, floor(map(e_bird, 130, 255, 1, 2, true) * birdScale));
        for (let i=0;i<n;i++) birds.push(new Bird(pickXFromBand(3000, 6000, spectrum)));
        lastSpawn.bird = millis();
      }

      // Caterpillar (rare)
      if (e_grass > 160 && millis() - lastSpawn.caterpillar > COOLDOWN.caterpillar && caterpillars.length < MAX_COUNTS.caterpillars) {
        caterpillars.push(new Caterpillar(random(width*0.1, width*0.9)));
        lastSpawn.caterpillar = millis();
      }

      // Big Drops (low band)
      if (e_bass > 140 && millis() - lastSpawn.drop > COOLDOWN.drop && drops.length < MAX_COUNTS.drops) {
        const c = floor(map(e_bass, 140, 255, 1, 3, true));
        for (let i=0;i<c;i++) drops.push(new Drop(pickXFromBand(40, 180, spectrum), -20 - random(0, 100)));
        lastSpawn.drop = millis();
      }

      // Big Stars (high band)
      if (e_high > 150 && millis() - lastSpawn.bigStar > COOLDOWN.bigStar && bigStars.length < MAX_COUNTS.bigStars) {
        const c = floor(map(e_high, 150, 255, 1, 3, true));
        for (let i=0;i<c;i++) bigStars.push(new BigStar(pickXFromBand(6000, 12000, spectrum), -20 - random(0, 140)));
        lastSpawn.bigStar = millis();
      }

      // Small peak stars (short sounds)
      if (peak.isDetected && millis() - lastSpawn.star > COOLDOWN.star && stars.length < MAX_COUNTS.stars) {
        const c = constrain(map(level, 0, 0.2, 1, 4), 1, 6);
        for (let i=0;i<c;i++) stars.push(new SmallStar(random(width), -20 - random(0, 100)));
        lastSpawn.star = millis();
      }

      // Noise dust (with adjustable sensitivity)
      const dustCount = floor(map(noiseIndex, noiseStart, 1.0, 0, 16, true));
      for (let i=0;i<dustCount && dust.length<MAX_COUNTS.dust; i++) {
        if (random()<0.6) dust.push(new DustStar(random(width), random(height*0.05, height*0.65), noiseIndex));
      }

      // ===== Update & Draw =====
      for (let i = dust.length-1; i>=0; i--) { dust[i].update(); dust[i].draw(silenceFade); if (dust[i].dead) dust.splice(i,1); }
      for (let i = drops.length-1; i>=0; i--) { drops[i].update(level); drops[i].draw(silenceFade); if (drops[i].dead) drops.splice(i,1); }
      for (let i = bigStars.length-1; i>=0; i--) { bigStars[i].update(level); bigStars[i].draw(silenceFade); if (bigStars[i].dead) bigStars.splice(i,1); }
      for (let i = stars.length-1; i>=0; i--) { stars[i].update(level); stars[i].draw(silenceFade); if (stars[i].dead) stars.splice(i,1); }

      for (let i = plants.length-1; i>=0; i--) { plants[i].update(e_grass, e_flower, level); plants[i].draw(silenceFade); if (plants[i].dead) plants.splice(i,1); }
      for (let i = butterflies.length-1; i>=0; i--) { butterflies[i].update(silenceFade); butterflies[i].draw(silenceFade); if (butterflies[i].dead) butterflies.splice(i,1); }
      for (let i = birds.length-1; i>=0; i--) { birds[i].update(e_bird, silenceFade); birds[i].draw(silenceFade); if (birds[i].dead) birds.splice(i,1); }
      for (let i = caterpillars.length-1; i>=0; i--) { caterpillars[i].update(); caterpillars[i].draw(silenceFade); if (caterpillars[i].dead) caterpillars.splice(i,1); }
    }

    // ======= Position mapping helpers =======
    function freqToXLog(freqHz) {
      const nyq = sampleRate() / 2;
      const f = constrain(freqHz, 20, nyq);
      const logMin = Math.log(20);
      const logMax = Math.log(nyq);
      const t = (Math.log(f) - logMin) / (logMax - logMin);
      return t * width;
    }

    function pickXFromBand(rangeStartHz, rangeEndHz, spectrum) {
      const nyq = sampleRate() / 2;
      const startBin = floor(map(rangeStartHz, 0, nyq, 0, spectrum.length));
      const endBin   = max(startBin+1, ceil(map(rangeEndHz, 0, nyq, 0, spectrum.length)));
      let acc = 0;
      for (let i=startBin;i<endBin;i++) acc += spectrum[i] + 1e-6;
      if (acc <= 0) return random(width);
      let r = random(acc), cum = 0, idx = startBin;
      for (; idx < endBin; idx++) { cum += spectrum[idx] + 1e-6; if (cum >= r) break; }
      const x = map(idx, startBin, endBin-1, 0, width, true);
      return constrain(x + random(-10,10), 0, width);
    }

    // ======= Entities =======
    class Plant {
      constructor(x, type) {
        this.x = x + random(-6, 6);
        this.type = type;
        this.life = 0;
        this.maxLife = random(90, 160);
        this.h = random(14, 26);
        this.swing = random(0.015, 0.03);
        this.seed = random(1000);
        this.dead = false;
      }
      update(e_grass, e_flower, level) {
        this.life++;
        const energy = (this.type === 'grass') ? e_grass : e_flower;
        const grow = map(energy, 80, 255, 0.4, 2.2, true);
        this.h += (grow - 0.5) * 0.4;
        if (this.life > this.maxLife) this.dead = true;
      }
      draw(silence) {
        const y0 = baselineY;
        const sway = sin(frameCount * this.swing + this.seed) * 6 * (1 - silence);
        const topX = this.x + sway;
        const topY = y0 - this.h * (1 - silence*0.95);
        stroke(255); strokeWeight(1.6); line(this.x, y0, topX, topY); noStroke();
        if (this.type === 'flower') {
          const r = 4 + (1 - silence) * 3;
          push(); translate(topX, topY); fill(255);
          for (let i=0;i<6;i++){ const a = i * PI/3 + this.seed*0.2; ellipse(cos(a)*r, sin(a)*r, r*0.9, r*0.9); }
          fill(255); circle(0,0, r*0.9); pop();
        } else {
          fill(255); circle(topX, topY, 2.2 + (1 - silence) * 1.2);
        }
      }
    }

    class Bird {
      constructor(targetX) {
        this.x = random(width);
        this.y = random(-80, -10);
        this.tx = targetX;
        this.ty = baselineY - 16;
        this.state = 'fly';
        this.timer = 0;
        this.dead = false;
      }
      update(e_bird, silence) {
        this.timer++;
        if (this.state === 'fly') {
          this.x += (this.tx - this.x) * 0.06;
          this.y += (this.ty - this.y) * 0.07;
          if (dist(this.x, this.y, this.tx, this.ty) < 2.5) { this.state = 'perch'; this.timer = 0; }
        } else {
          this.y = this.ty + sin(frameCount * 0.05) * 0.6 * (1 - silence);
          if (this.timer > 800 || silence > 0.8) { this.state = 'fly'; this.ty = -50; }
        }
        if (this.y < -60 && this.state === 'fly' && this.timer > 200) this.dead = true;
      }
      draw(silence) {
        push(); translate(this.x, this.y); const s = 1.0; fill(255); noStroke();
        ellipse(0, 0, 14*s, 10*s); ellipse(-6*s, -3*s, 7*s, 6*s); triangle( -9*s, -3*s, -13*s, -2*s, -9*s, -1*s );
        push(); translate(3*s, 0); rotate(sin(frameCount*0.25) * 0.35 * (this.state==='fly' ? 1 : 0.2) * (1 - silence)); ellipse(0, 0, 10*s, 5*s); pop();
        pop();
      }
    }

    class Butterfly {
      constructor(x) {
        this.x = x; this.y = baselineY - random(60, 140);
        this.vx = random(-1.2, 1.2); this.vy = random(-0.6, 0.6);
        this.phase = random(TWO_PI); this.life = 0; this.maxLife = random(300, 600);
        this.dead = false;
      }
      update(silence) {
        this.life++; this.phase += 0.2;
        this.x += this.vx + sin(this.phase) * 0.6;
        this.y += this.vy + cos(this.phase*1.3) * 0.4;
        this.x = constrain(this.x, 0, width);
        this.y = constrain(this.y, height*0.15, baselineY - 8);
        if (this.life > this.maxLife || silence > 0.95) this.dead = true;
      }
      draw(silence) {
        push(); translate(this.x, this.y); noStroke(); fill(255, 220*(1-silence));
        const flap = 0.9 + sin(frameCount*0.4) * 0.4 * (1 - silence);
        ellipse(-5, 0, 8*flap, 12*flap); ellipse(-8, 2, 6*flap, 10*flap);
        ellipse( 5, 0, 8*flap, 12*flap); ellipse( 8, 2, 6*flap, 10*flap);
        rectMode(CENTER); rect(0, 0, 2, 8, 1);
        pop();
      }
    }

    class Caterpillar {
      constructor(x) {
        this.x = x; this.y = baselineY - 2;
        this.dir = random()<0.5 ? -1 : 1;
        this.speed = random(0.4, 0.8) * this.dir;
        this.phase = random(TWO_PI); this.life = 0; this.maxLife = random(600, 1200);
        this.dead = false;
      }
      update() {
        this.life++; this.phase += 0.15;
        this.x += this.speed + sin(this.phase)*0.3;
        if (this.x < -40 || this.x > width+40 || this.life > this.maxLife) this.dead = true;
      }
      draw(silence) {
        push(); translate(this.x, this.y); noStroke();
        const segs = 7;
        for (let i=0;i<segs;i++) { const off = sin(this.phase + i*0.6) * 2.2; circle(i*4, off, 4); }
        pop();
      }
    }

    class SmallStar {
      constructor(x, y) { this.x=x; this.y=y; this.vy = random(2.0, 5.0); this.size = random(2, 4.5); this.life=0; this.maxLife=random(120, 220); this.dead=false; }
      update(level) { this.life++; this.y += this.vy + level * 20; if (this.life > this.maxLife || this.y > height + 20) this.dead = true; }
      draw(silence) { push(); translate(this.x, this.y); const a = map(this.life, 0, this.maxLife, 255, 0) * (1 - silence); fill(255, a); noStroke();
        rectMode(CENTER); rect(0, 0, this.size, this.size*0.3, 1.5); rect(0, 0, this.size*0.3, this.size, 1.5); pop(); }
    }

    class BigStar {
      constructor(x, y) { this.x=x; this.y=y; this.vy = random(1.6, 3.2); this.size = random(8, 14); this.life=0; this.maxLife=random(160, 300); this.dead=false; this.spin = random(-0.03, 0.03); }
      update(level) { this.life++; this.y += this.vy + level * 14; if (this.life > this.maxLife || this.y > height + 30) this.dead = true; }
      draw(silence) {
        push(); translate(this.x, this.y); rotate(this.spin*frameCount); const a = 220*(1-silence); fill(255, a); noStroke();
        starShape(0,0,this.size*0.4,this.size,5); pop();
      }
    }

    class Drop {
      constructor(x, y) { this.x=x; this.y=y; this.vy = random(2.2, 4.2); this.size = random(8, 12); this.life=0; this.dead=false; this.splashed=false; }
      update(level) {
        this.life++; this.y += this.vy + level*10;
        if (!this.splashed && this.y >= baselineY-1) { this.splashed=true; this.y = baselineY-1; this.life = 0; }
        if (this.splashed && this.life > 30) this.dead = true;
      }
      draw(silence) {
        const a = 230*(1-silence);
        if (!this.splashed) {
          push(); translate(this.x, this.y); noStroke(); fill(255, a);
          ellipse(0, 0, this.size*0.7, this.size); pop();
        } else {
          push(); translate(this.x, baselineY-1); stroke(255, a); noFill();
          arc(0, 0, 12, 6, PI, PI*2); arc(0, 0, 18, 8, PI, PI*2); pop();
        }
      }
    }

    class DustStar {
      constructor(x, y, noiseIndex) {
        this.x = x; this.y = y;
        this.life = 0; this.maxLife = random(80, 180);
        this.size = map(noiseIndex, 0.6, 1.0, 0.8, 2.6, true) * random(0.7, 1.3);
        this.alpha = random(80, 170);
        this.dead = false;
      }
      update() { this.life++; if (this.life > this.maxLife) this.dead = true; }
      draw(silence) { const a = this.alpha * (1 - silence); fill(255, a); noStroke(); circle(this.x, this.y, this.size); }
    }

    function starShape(x, y, r1, r2, n) {
      beginShape();
      for (let i = 0; i < n; i++) {
        const a = TWO_PI * i / n - PI/2;
        const x1 = x + cos(a) * r2;
        const y1 = y + sin(a) * r2;
        vertex(x1, y1);
        const a2 = a + PI / n;
        const x2 = x + cos(a2) * r1;
        const y2 = y + sin(a2) * r1;
        vertex(x2, y2);
      }
      endShape(CLOSE);
    }
  </script>
</body>
</html>
