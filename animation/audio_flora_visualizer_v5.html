<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Audio Visualizer v5 â€“ åŒè‘‰/èŠ±ãƒ¡ã‚¤ãƒ³ãƒ»åœ°ç‚¹ã”ã¨æœ€å¤§3æœ¬ãƒ»ğŸ¦‹å°ã•ãå°‘ãªããƒ»UIæœ€å°åŒ–</title>
  <!-- p5.js & sound addon -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.sound.min.js"></script>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; padding:0; background:#0b0b0f; color:#eee; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "Noto Sans JP", sans-serif; }
    #ui {
      position: fixed; left: 16px; top: 16px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
      background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
      padding: 8px 10px; border-radius: 12px; backdrop-filter: blur(6px); z-index:2;
    }
    #ui button, #ui label {
      appearance: none; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.08);
      color: #eee; padding: 6px 10px; border-radius: 10px; cursor: pointer; font-size: 12px;
    }
    #ui button:hover, #ui label:hover { background: rgba(255,255,255,0.16); }
    #file { display: none; }
    #legend {
      position: fixed; right: 16px; top: 16px; font-size: 12px; line-height: 1.45;
      color: #cfd7ff; opacity: .9; background: rgba(16,16,24,.35); border: 1px solid rgba(255,255,255,.08);
      padding: 8px 10px; border-radius: 10px; z-index:2; max-width: 42ch;
    }
    #uiShow {
      position: fixed; left: 12px; bottom: 12px; z-index: 3; display:none;
      border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.08);
      color:#eee; padding:6px 10px; border-radius: 999px; cursor:pointer; font-size:12px;
    }
    a { color: #9ec5ff; }
    .active { outline: 1px solid rgba(255,255,255,0.5); }
  </style>
</head>
<body>
  <div id="ui">
    <label for="file">éŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«</label><input id="file" type="file" accept="audio/*"/>
    <button id="mic">ãƒã‚¤ã‚¯</button>
    <button id="play">å†ç”Ÿ</button>
    <button id="pause">ä¸€æ™‚åœæ­¢</button>
    <button id="record">éŒ²ç”»é–‹å§‹</button>
    <button id="minimize">UIæœ€å°åŒ–</button>
    <span id="status" style="margin-left:8px; font-size:12px; opacity:.85;">æº–å‚™ä¸­</span>
  </div>
  <button id="uiShow">ğŸ”§ UI</button>
  <div id="legend">
    <div>â€” ç™½ã„ç·š: åŸºæº–</div>
    <div>ğŸŒ± åŒè‘‰ãƒ»ğŸŒ¼ èŠ±: 200â€“2000Hzï¼ˆ<b>åŒä¸€åœ°ç‚¹ã¯æœ€å¤§3æœ¬</b>ã€‚å ´æ‰€ãŒé•ãˆã°ç„¡åˆ¶é™ï¼‰</div>
    <div>ğŸ¦‹ ã¡ã‚‡ã†ã¡ã‚‡: <b>2000Hzä»¥ä¸Š</b>ï¼ˆå°ã•ã‚ï¼å°‘ãªã‚ï¼‰</div>
    <div>âœ¨ æ˜Ÿã‚­ãƒ©ã‚­ãƒ©: é¢¨æ™¯ãƒã‚¤ã‚ºï¼ˆã‚¹ãƒšã‚¯ãƒˆãƒ«å¹³å¦ã•ï¼‰</div>
    <div>â˜„ï¸ é•·ã„æµæ˜Ÿ: ä½/è¶…é«˜å¸¯åŸŸ or å¤§ããªéŸ³é‡</div>
    <div>ç„¡éŸ³/çµ‚äº† â†’ ç™½ç·šã®ã¿</div>
  </div>

  <script>
    // ======= Audio + Analysis =======
    let fft, amp, mic, sound, usingMic = false, fileLoaded = false;
    let lastActiveMillis = 0;   // éŸ³ãŒé³´ã£ã¦ã„ã‚‹æœ€çµ‚æ™‚åˆ»
    let silenceFade = 0;        // ç„¡éŸ³æ™‚ã®ãƒ•ã‚§ãƒ¼ãƒ‰ 0..1
    const noiseGate = 0.008;

    // ======= Visual State =======
    const plants = [];      // sprout/flower
    const butterflies = []; // ğŸ¦‹
    const dustStars = [];   // background twinkles
    const meteors = [];     // â˜„ï¸
    let baselineY;

    // åœ°ç‚¹ã”ã¨ã®ã€ŒåŒæ™‚æœ€å¤§3æœ¬ã€åˆ¶ç´„ç”¨ã®ãƒ“ãƒ³ï¼ˆæ¨ªæ–¹å‘ï¼‰
    let NUM_BINS = 36; // ç”»é¢å¹…ã«å¿œã˜ã¦å¾Œã§æ›´æ–°
    let BIN_W = 0;

    const E = { level:0, plantBand:0, bflyBand:0, bass:0, ultra:0, entropy:0 };
    let plantPeak; // peak detector for plant band

    // ======= Recording =======
    let mediaRecorder = null, recordedChunks = [], destNode = null;

    function setup() {
      createCanvas(window.innerWidth, window.innerHeight);
      pixelDensity(window.devicePixelRatio || 1);
      baselineY = height * 0.85;

      fft = new p5.FFT(0.85, 1024);   // å°‘ã—å¼·ã‚ã®ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°
      amp = new p5.Amplitude();
      plantPeak = new p5.PeakDetect(200, 2000, 0.12, 14); // æ¤ç‰©å¸¯ã®ãƒ”ãƒ¼ã‚¯

      textFont('Noto Sans JP, system-ui, sans-serif');
      noStroke();

      calcBins();
      bindUI();
    }

    function calcBins(){
      NUM_BINS = max(24, floor(width / 48)); // ãŠãŠã‚ˆã48px/ãƒ“ãƒ³
      BIN_W = width / NUM_BINS;
    }

    function bindUI() {
      const fileInput = document.getElementById('file');
      const micBtn = document.getElementById('mic');
      const playBtn = document.getElementById('play');
      const pauseBtn = document.getElementById('pause');
      const recBtn = document.getElementById('record');
      const minimizeBtn = document.getElementById('minimize');
      const ui = document.getElementById('ui');
      const uiShow = document.getElementById('uiShow');
      const legend = document.getElementById('legend');
      const status = document.getElementById('status');

      fileInput.addEventListener('change', async (e) => {
        await userStartAudio();
        stopAllAudio();
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        sound = loadSound(url, () => {
          fileLoaded = true; usingMic = false;
          amp.setInput(sound); fft.setInput(sound);
          status.textContent = 'ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿å®Œäº†';
          sound.onended(() => { lastActiveMillis = millis() - 5000; });
        }, (err)=>{ status.textContent = 'èª­ã¿è¾¼ã¿å¤±æ•—'; console.error(err); });
      });

      micBtn.addEventListener('click', async () => {
        await userStartAudio();
        stopAllAudio();
        mic = new p5.AudioIn();
        mic.start(() => {
          usingMic = true; fileLoaded = false;
          amp.setInput(mic); fft.setInput(mic);
          status.textContent = 'ãƒã‚¤ã‚¯å…¥åŠ›ä¸­';
        }, (err)=>{ status.textContent = 'ãƒã‚¤ã‚¯è¨±å¯ã‚¨ãƒ©ãƒ¼'; console.error(err); });
      });

      playBtn.addEventListener('click', async () => {
        await userStartAudio();
        if (sound && fileLoaded) {
          if (!sound.isPlaying()) sound.play();
          status.textContent = 'å†ç”Ÿä¸­';
        }
      });
      pauseBtn.addEventListener('click', () => {
        if (sound && sound.isPlaying()) { sound.pause(); status.textContent = 'ä¸€æ™‚åœæ­¢'; }
      });

      minimizeBtn.addEventListener('click', () => {
        ui.style.display = 'none';
        legend.style.display = 'none';
        uiShow.style.display = 'inline-block';
      });
      uiShow.addEventListener('click', () => {
        ui.style.display = '';
        legend.style.display = '';
        uiShow.style.display = 'none';
      });

      recBtn.addEventListener('click', async () => {
        if (!mediaRecorder) {
          await startRecording();
          recBtn.textContent = 'éŒ²ç”»åœæ­¢';
          recBtn.classList.add('active');
        } else {
          await stopRecording();
          recBtn.textContent = 'éŒ²ç”»é–‹å§‹';
          recBtn.classList.remove('active');
        }
      });
    }

    function windowResized() {
      resizeCanvas(window.innerWidth, window.innerHeight);
      baselineY = height * 0.85;
      calcBins();
    }

    function stopAllAudio() {
      if (sound) { try { sound.stop(); } catch(e){} }
      if (mic) { try { mic.stop(); } catch(e){} }
    }

    function draw() {
      background(11, 11, 15, 255);

      // è§£æ
      const spectrum = fft.analyze();
      let level = amp.getLevel();
      E.level = lerp(E.level, level, 0.2);
      plantPeak.update(fft);

      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–åˆ¤å®šï¼ˆç„¡éŸ³ã‹ã©ã†ã‹ï¼‰
      const active = level > noiseGate || (sound && sound.isPlaying());
      if (active) lastActiveMillis = millis();

      // ç„¡éŸ³æ™‚ã¯ãƒ•ã‚§ãƒ¼ãƒ‰ã‚’ä¸Šã’ã€éŸ³ãŒé³´ã‚‹ã¨ä¸‹ã’ã‚‹
      const silentFor = millis() - lastActiveMillis;
      if (silentFor > 900) { silenceFade = min(1, silenceFade + 0.03); }
      else { silenceFade = max(0, silenceFade - 0.05); }

      // ç™½ã„åŸºæº–ç·šï¼ˆå¸¸ã«è¡¨ç¤ºï¼‰
      stroke(255); strokeWeight(3);
      line(0, baselineY, width, baselineY);
      noStroke();

      // ====== æŒ‡æ¨™è¨ˆç®— ======
      const plantBand = fft.getEnergy(200, 2000); // ãƒ¡ã‚¤ãƒ³å¸¯åŸŸ
      const bflyBand  = fft.getEnergy(2000, 8000); // ğŸ¦‹ã¯2000Hzä»¥ä¸Š
      const bass   = fft.getEnergy(20, 120);
      const ultra  = fft.getEnergy(8000, 16000);

      // ã‚¹ãƒšã‚¯ãƒˆãƒ«æ­£è¦åŒ–ã—ã¦ã‚¨ãƒ³ãƒˆãƒ­ãƒ”ãƒ¼ï¼ˆãƒã‚¤ã‚ºæŒ‡æ•°ï¼‰
      let sum = 0; for (let i=0;i<spectrum.length;i++) sum += spectrum[i] + 1e-6;
      let entropy = 0;
      for (let i=0;i<spectrum.length;i++) { const p = (spectrum[i] + 1e-6) / sum; entropy += -p * Math.log(p); }
      entropy = entropy / Math.log(spectrum.length); // 0..1

      E.plantBand = lerp(E.plantBand, plantBand, 0.25);
      E.bflyBand  = lerp(E.bflyBand, bflyBand, 0.25);
      E.bass      = lerp(E.bass,   bass,   0.25);
      E.ultra     = lerp(E.ultra,  ultra,  0.25);
      E.entropy   = lerp(E.entropy,entropy,0.25);

      // ====== èƒŒæ™¯ãƒã‚¤ã‚º â†’ ã‚­ãƒ©ã‚­ãƒ©æ˜Ÿ ======
      const dustCount = floor(map(E.entropy, 0.6, 1.0, 0, 10, true));
      for (let i=0;i<dustCount;i++) {
        dustStars.push(new DustStar(random(width), random(height*0.05, height*0.65), E.entropy));
      }

      // ====== åŒè‘‰ãƒ»èŠ±ï¼ˆåœ°ç‚¹ã”ã¨æœ€å¤§3æœ¬ / è‡ªç„¶æˆé•· / ç„¡åˆ¶é™æ•°ï¼‰ ======
      // é€šå¸¸ç”Ÿæˆï¼ˆæ§ãˆã‚ï¼‰
      if (E.plantBand > 70 && random() < 0.35) {
        spawnPlantSmart(E.plantBand);
      }
      // æ¤ç‰©å¸¯ã®ãƒ”ãƒ¼ã‚¯ã§ã€Œã¶ã‚ã£ã€
      if (plantPeak.isDetected) {
        const burst = floor(random(3, 7)); // 3ã€œ6æœ¬
        for (let i=0;i<burst;i++) spawnPlantSmart(E.plantBand);
      }

      // ====== ã¡ã‚‡ã†ã¡ã‚‡ï¼ˆå°ã•ããƒ»å°‘ãªã‚ãƒ»2000Hzä»¥ä¸Šï¼‰ ======
      if ((E.bflyBand > 120 && random() < 0.012) || random() < 0.003) {
        butterflies.push(new Butterfly(random(width), random(height*0.35, height*0.75), 0.5)); // scaleBase=0.5
      }

      // ====== æµæ˜Ÿï¼ˆæŸ”è»Ÿãƒˆãƒªã‚¬ï¼šéŸ³é‡/ä½åŸŸ/è¶…é«˜åŸŸ ã„ãšã‚Œã‹ãŒé«˜ã‚ï¼‰ ======
      const meteorTrig = (E.level > 0.18) || (E.bass > 130) || (E.ultra > 130);
      if (meteorTrig && meteors.length < 6 && random() < 0.25) {
        const dir = random([-1, 1]);
        const startX = (dir>0 ? random(width*0.05, width*0.45) : random(width*0.55, width*0.95));
        const startY = random(height*0.05, height*0.5);
        const vx = dir * random(7.5, 10.5);
        const vy = random(6.0, 9.0);
        meteors.push(new Meteor(startX, startY, vx, vy, floor(random(28, 50))));
      }

      // ====== æ›´æ–°ãƒ»æç”» ======
      for (let i = dustStars.length-1; i>=0; i--) { dustStars[i].update(); dustStars[i].draw(silenceFade); if (dustStars[i].dead) dustStars.splice(i,1); }
      for (let i = meteors.length-1; i>=0; i--) { meteors[i].update(); meteors[i].draw(silenceFade); if (meteors[i].dead) meteors.splice(i,1); }
      for (let i = plants.length-1; i>=0; i--) { plants[i].update(); plants[i].draw(silenceFade); if (plants[i].dead) plants.splice(i,1); }
      for (let i = butterflies.length-1; i>=0; i--) { butterflies[i].update(); butterflies[i].draw(silenceFade); if (butterflies[i].dead) butterflies.splice(i,1); }

      if (silenceFade > 0.95) { /* ç™½ç·šã®ã¿ */ }
    }

    // ====== Plant spawn helpers ======
    function xToBin(x){ return constrain(floor(x / BIN_W), 0, NUM_BINS-1); }
    function countPlantsInBin(bi){
      let c = 0;
      for (let p of plants){
        if (p.dead) continue;
        const b = xToBin(p.x);
        if (b === bi) c++;
      }
      return c;
    }
    function spawnPlantSmart(energy){
      // ãƒ©ãƒ³ãƒ€ãƒ ã«ä½ç½®ã‚’é¸ã³ã¤ã¤ã€åŒä¸€ãƒ“ãƒ³ã§3æœ¬æœªæº€ã«ãªã‚‹ã‚ˆã†æ¢ã™
      let tries = 10;
      while (tries-- > 0){
        const x = random(width);
        const bi = xToBin(x);
        if (countPlantsInBin(bi) < 3){
          const type = (random() < 0.55 ? 'sprout' : 'flower'); // åŒè‘‰å¤šã‚
          plants.push(new Plant(x, type, energy));
          break;
        }
      }
    }

    // ======= ã‚¯ãƒ©ã‚¹ =======
    function easeOutCubic(t){ return 1 - pow(1 - t, 3); }
    function easeOutBack(t){ const c1 = 1.70158, c3 = c1 + 1; return 1 + c3*pow(t-1,3) + c1*pow(t-1,2); }

    class Plant {
      constructor(x, type, energy) {
        this.x = x;
        this.type = type; // 'sprout' or 'flower'
        this.life = 0;
        this.dead = false;

        // ã‚„ã‚„å¤§ãã‚ãƒ»åŒè‘‰ã¯ä½ã‚
        const baseH = (type==='sprout') ? random(10, 18) : random(22, 44);
        const sizeK = map(energy, 70, 255, 0.9, 1.4, true);
        this.hTarget = baseH * sizeK;

        // æˆé•·ã‚¢ãƒ‹ãƒ¡
        this.growFrames = floor(random(48, 90));   // 0.8ã€œ1.5ç§’
        this.bloomStart = this.growFrames * 0.55;
        this.age = 0;
        this.maxAge = this.growFrames + floor(random(90, 160));

        // è¦‹ãŸç›®ã‚µã‚¤ã‚º
        this.leafW = random(10, 16) * sizeK * (type==='sprout'?1.2:1.0);
        this.leafH = random(5.5, 8.0) * sizeK * (type==='sprout'?1.2:1.0);
        this.flowerR = random(7, 12) * sizeK;

        // é¢¨æºã‚Œ
        this.swing = random(0.012, 0.022);
        this.seed = random(1000);
      }
      update() {
        this.age++;
        if (this.age > this.maxAge) this.dead = true;
      }
      draw(silence) {
        const y0 = baselineY;
        const t = constrain(this.age / this.growFrames, 0, 1);
        const grow = easeOutCubic(t);
        const sway = sin(frameCount * this.swing + this.seed) * 5 * (1 - silence);
        const stemH = this.hTarget * grow * (1 - silence*0.95);
        const topX = this.x + sway;
        const topY = y0 - stemH;

        // stem
        stroke(255); strokeWeight(1.8);
        line(this.x, y0, topX, topY);
        noStroke();

        if (this.type === 'flower') {
          // ã¤ã¼ã¿â†’é–‹èŠ±
          const bt = t < 0.001 ? 0 : constrain((this.age - this.bloomStart)/ (this.growFrames - this.bloomStart + 1), 0, 1);
          const open = easeOutBack(bt);
          const r = this.flowerR * (0.4 + 0.6 * open) * (1 - silence*0.9);
          push();
          translate(topX, topY);
          fill(255);
          for (let i=0;i<6;i++){
            const a = i * PI/3 + this.seed*0.2;
            const pr = r * 0.95;
            ellipse(cos(a)*pr, sin(a)*pr, pr*0.95, pr*0.95);
          }
          fill(255);
          circle(0,0, r*0.9);
          pop();
        } else {
          // åŒè‘‰ï¼šå¤§ãã‚2æšè‘‰
          const lr = easeOutBack(t);
          const lw = this.leafW * lr * (1 - silence*0.9);
          const lh = this.leafH * lr * (1 - silence*0.9);
          push();
          translate(topX, topY);
          fill(255);
          ellipse(-lw*0.7, 0, lw, lh);
          ellipse(+lw*0.7, 0, lw, lh);
          pop();
        }
      }
    }

    class Butterfly {
      constructor(x, y, scaleBase=0.5) { // ä»¥å‰ã®ç´„1/2ã‚µã‚¤ã‚º
        this.x = x; this.y = y;
        this.life = 0; this.maxLife = 300 + random(120);
        this.dead = false;
        // ãµã‚ãµã‚å‹•ãï¼ˆæ§ãˆã‚ï¼‰
        this.vx = random(-0.5, 0.5);
        this.vy = random(-0.25, 0.25);
        this.phase = random(TWO_PI);
        // è¦‹ãŸç›®ã‚¹ã‚±ãƒ¼ãƒ«ï¼ˆå°ã•ãï¼‰
        this.s = scaleBase * random(0.9, 1.1);
      }
      update() {
        this.life++;
        this.phase += 0.05;
        this.x += this.vx + sin(this.phase*1.6) * 0.6;
        this.y += this.vy + cos(this.phase*1.1) * 0.45;
        this.x = constrain(this.x, -20, width+20);
        this.y = constrain(this.y, height*0.25, baselineY - 12);
        if (this.life > this.maxLife) this.dead = true;
      }
      draw(silence) {
        const a = (1 - silence) * 220 * (1 - this.life/this.maxLife);
        push();
        translate(this.x, this.y);
        scale(this.s);
        noStroke();
        fill(255, a);
        const flap = 0.9 + sin(frameCount*0.45) * 0.30 * (1 - silence);
        push();
        scale(flap, 1);
        ellipse(-9, -2, 16, 12);
        ellipse(-8,  5, 14, 10);
        ellipse( 9, -2, 16, 12);
        ellipse( 8,  5, 14, 10);
        pop();
        rectMode(CENTER); rect(0, 0, 2.2, 12, 2);
        stroke(255, a); strokeWeight(1); noFill();
        bezier(-1, -6, -5, -10, -7, -12, -8, -13);
        bezier( 1, -6,  5, -10,  7, -12,  8, -13);
        pop();
      }
    }

    class DustStar {
      constructor(x, y, noiseIndex) {
        this.x = x; this.y = y;
        this.life = 0;
        this.maxLife = random(80, 180);
        this.size = map(noiseIndex, 0.6, 1.0, 0.9, 2.8, true) * random(0.8, 1.4);
        this.alpha = random(90, 180);
        this.dead = false;
      }
      update() { this.life++; if (this.life > this.maxLife) this.dead = true; }
      draw(silence) {
        const a = this.alpha * (1 - silence);
        fill(255, a);
        noStroke();
        circle(this.x, this.y, this.size);
      }
    }

    class Meteor {
      constructor(x, y, vx, vy, life) {
        this.x = x; this.y = y;
        this.vx = vx; this.vy = vy;
        this.life = 0; this.maxLife = life;
        this.dead = false;
        this.trail = [];
      }
      update() {
        this.life++;
        this.trail.push({x:this.x, y:this.y});
        if (this.trail.length > 20) this.trail.shift();
        this.x += this.vx; this.y += this.vy;
        if (this.life > this.maxLife) this.dead = true;
      }
      draw(silence) {
        const alpha = 230 * (1 - silence);
        noFill();
        for (let i=0;i<this.trail.length-1;i++) {
          const p1 = this.trail[i], p2 = this.trail[i+1];
          const a = alpha * (i / this.trail.length);
          stroke(255, a);
          strokeWeight(map(i, 0, this.trail.length-1, 1, 3.2));
          line(p1.x, p1.y, p2.x, p2.y);
        }
        noStroke();
        fill(255, alpha);
        ellipse(this.x, this.y, 4.5, 4.5);
      }
    }

    // ======= Recording (Canvas + Audio) =======
    async function startRecording() {
      if (mediaRecorder) return;
      const canvasStream = document.querySelector('canvas').captureStream(60);
      const ac = getAudioContext();
      if (!destNode) {
        destNode = ac.createMediaStreamDestination();
        try { p5.soundOut.output.connect(destNode); } catch(e){ console.warn('audio connect failed', e); }
      }
      const combined = new MediaStream([ ...canvasStream.getVideoTracks(), ...destNode.stream.getAudioTracks() ]);
      mediaRecorder = new MediaRecorder(combined, { mimeType: 'video/webm;codecs=vp9,opus' });
      recordedChunks = [];
      mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = e => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'visualizer_v5.webm';
        a.click();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
        mediaRecorder = null;
      };
      mediaRecorder.start();
    }

    async function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
    }
  </script>
</body>
</html>