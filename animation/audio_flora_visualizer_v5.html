<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Audio Visualizer v5 – 双葉/花メイン・地点ごと最大3本・🦋小さく少なく・UI最小化</title>
  <!-- p5.js & sound addon -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.sound.min.js"></script>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; padding:0; background:#0b0b0f; color:#eee; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "Noto Sans JP", sans-serif; }
    #ui {
      position: fixed; left: 16px; top: 16px; display: flex; gap: 8px; align-items: center; flex-wrap: wrap;
      background: rgba(255,255,255,0.07); border: 1px solid rgba(255,255,255,0.1);
      padding: 8px 10px; border-radius: 12px; backdrop-filter: blur(6px); z-index:2;
    }
    #ui button, #ui label {
      appearance: none; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.08);
      color: #eee; padding: 6px 10px; border-radius: 10px; cursor: pointer; font-size: 12px;
    }
    #ui button:hover, #ui label:hover { background: rgba(255,255,255,0.16); }
    #file { display: none; }
    #legend {
      position: fixed; right: 16px; top: 16px; font-size: 12px; line-height: 1.45;
      color: #cfd7ff; opacity: .9; background: rgba(16,16,24,.35); border: 1px solid rgba(255,255,255,.08);
      padding: 8px 10px; border-radius: 10px; z-index:2; max-width: 42ch;
    }
    #uiShow {
      position: fixed; left: 12px; bottom: 12px; z-index: 3; display:none;
      border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.08);
      color:#eee; padding:6px 10px; border-radius: 999px; cursor:pointer; font-size:12px;
    }
    a { color: #9ec5ff; }
    .active { outline: 1px solid rgba(255,255,255,0.5); }
  </style>
</head>
<body>
  <div id="ui">
    <label for="file">音声ファイル</label><input id="file" type="file" accept="audio/*"/>
    <button id="mic">マイク</button>
    <button id="play">再生</button>
    <button id="pause">一時停止</button>
    <button id="record">録画開始</button>
    <button id="minimize">UI最小化</button>
    <span id="status" style="margin-left:8px; font-size:12px; opacity:.85;">準備中</span>
  </div>
  <button id="uiShow">🔧 UI</button>
  <div id="legend">
    <div>— 白い線: 基準</div>
    <div>🌱 双葉・🌼 花: 200–2000Hz（<b>同一地点は最大3本</b>。場所が違えば無制限）</div>
    <div>🦋 ちょうちょ: <b>2000Hz以上</b>（小さめ／少なめ）</div>
    <div>✨ 星キラキラ: 風景ノイズ（スペクトル平坦さ）</div>
    <div>☄️ 長い流星: 低/超高帯域 or 大きな音量</div>
    <div>無音/終了 → 白線のみ</div>
  </div>

  <script>
    // ======= Audio + Analysis =======
    let fft, amp, mic, sound, usingMic = false, fileLoaded = false;
    let lastActiveMillis = 0;   // 音が鳴っている最終時刻
    let silenceFade = 0;        // 無音時のフェード 0..1
    const noiseGate = 0.008;

    // ======= Visual State =======
    const plants = [];      // sprout/flower
    const butterflies = []; // 🦋
    const dustStars = [];   // background twinkles
    const meteors = [];     // ☄️
    let baselineY;

    // 地点ごとの「同時最大3本」制約用のビン（横方向）
    let NUM_BINS = 36; // 画面幅に応じて後で更新
    let BIN_W = 0;

    const E = { level:0, plantBand:0, bflyBand:0, bass:0, ultra:0, entropy:0 };
    let plantPeak; // peak detector for plant band

    // ======= Recording =======
    let mediaRecorder = null, recordedChunks = [], destNode = null;

    function setup() {
      createCanvas(window.innerWidth, window.innerHeight);
      pixelDensity(window.devicePixelRatio || 1);
      baselineY = height * 0.85;

      fft = new p5.FFT(0.85, 1024);   // 少し強めのスムージング
      amp = new p5.Amplitude();
      plantPeak = new p5.PeakDetect(200, 2000, 0.12, 14); // 植物帯のピーク

      textFont('Noto Sans JP, system-ui, sans-serif');
      noStroke();

      calcBins();
      bindUI();
    }

    function calcBins(){
      NUM_BINS = max(24, floor(width / 48)); // おおよそ48px/ビン
      BIN_W = width / NUM_BINS;
    }

    function bindUI() {
      const fileInput = document.getElementById('file');
      const micBtn = document.getElementById('mic');
      const playBtn = document.getElementById('play');
      const pauseBtn = document.getElementById('pause');
      const recBtn = document.getElementById('record');
      const minimizeBtn = document.getElementById('minimize');
      const ui = document.getElementById('ui');
      const uiShow = document.getElementById('uiShow');
      const legend = document.getElementById('legend');
      const status = document.getElementById('status');

      fileInput.addEventListener('change', async (e) => {
        await userStartAudio();
        stopAllAudio();
        const file = e.target.files[0];
        if (!file) return;
        const url = URL.createObjectURL(file);
        sound = loadSound(url, () => {
          fileLoaded = true; usingMic = false;
          amp.setInput(sound); fft.setInput(sound);
          status.textContent = 'ファイル読み込み完了';
          sound.onended(() => { lastActiveMillis = millis() - 5000; });
        }, (err)=>{ status.textContent = '読み込み失敗'; console.error(err); });
      });

      micBtn.addEventListener('click', async () => {
        await userStartAudio();
        stopAllAudio();
        mic = new p5.AudioIn();
        mic.start(() => {
          usingMic = true; fileLoaded = false;
          amp.setInput(mic); fft.setInput(mic);
          status.textContent = 'マイク入力中';
        }, (err)=>{ status.textContent = 'マイク許可エラー'; console.error(err); });
      });

      playBtn.addEventListener('click', async () => {
        await userStartAudio();
        if (sound && fileLoaded) {
          if (!sound.isPlaying()) sound.play();
          status.textContent = '再生中';
        }
      });
      pauseBtn.addEventListener('click', () => {
        if (sound && sound.isPlaying()) { sound.pause(); status.textContent = '一時停止'; }
      });

      minimizeBtn.addEventListener('click', () => {
        ui.style.display = 'none';
        legend.style.display = 'none';
        uiShow.style.display = 'inline-block';
      });
      uiShow.addEventListener('click', () => {
        ui.style.display = '';
        legend.style.display = '';
        uiShow.style.display = 'none';
      });

      recBtn.addEventListener('click', async () => {
        if (!mediaRecorder) {
          await startRecording();
          recBtn.textContent = '録画停止';
          recBtn.classList.add('active');
        } else {
          await stopRecording();
          recBtn.textContent = '録画開始';
          recBtn.classList.remove('active');
        }
      });
    }

    function windowResized() {
      resizeCanvas(window.innerWidth, window.innerHeight);
      baselineY = height * 0.85;
      calcBins();
    }

    function stopAllAudio() {
      if (sound) { try { sound.stop(); } catch(e){} }
      if (mic) { try { mic.stop(); } catch(e){} }
    }

    function draw() {
      background(11, 11, 15, 255);

      // 解析
      const spectrum = fft.analyze();
      let level = amp.getLevel();
      E.level = lerp(E.level, level, 0.2);
      plantPeak.update(fft);

      // アクティブ判定（無音かどうか）
      const active = level > noiseGate || (sound && sound.isPlaying());
      if (active) lastActiveMillis = millis();

      // 無音時はフェードを上げ、音が鳴ると下げる
      const silentFor = millis() - lastActiveMillis;
      if (silentFor > 900) { silenceFade = min(1, silenceFade + 0.03); }
      else { silenceFade = max(0, silenceFade - 0.05); }

      // 白い基準線（常に表示）
      stroke(255); strokeWeight(3);
      line(0, baselineY, width, baselineY);
      noStroke();

      // ====== 指標計算 ======
      const plantBand = fft.getEnergy(200, 2000); // メイン帯域
      const bflyBand  = fft.getEnergy(2000, 8000); // 🦋は2000Hz以上
      const bass   = fft.getEnergy(20, 120);
      const ultra  = fft.getEnergy(8000, 16000);

      // スペクトル正規化してエントロピー（ノイズ指数）
      let sum = 0; for (let i=0;i<spectrum.length;i++) sum += spectrum[i] + 1e-6;
      let entropy = 0;
      for (let i=0;i<spectrum.length;i++) { const p = (spectrum[i] + 1e-6) / sum; entropy += -p * Math.log(p); }
      entropy = entropy / Math.log(spectrum.length); // 0..1

      E.plantBand = lerp(E.plantBand, plantBand, 0.25);
      E.bflyBand  = lerp(E.bflyBand, bflyBand, 0.25);
      E.bass      = lerp(E.bass,   bass,   0.25);
      E.ultra     = lerp(E.ultra,  ultra,  0.25);
      E.entropy   = lerp(E.entropy,entropy,0.25);

      // ====== 背景ノイズ → キラキラ星 ======
      const dustCount = floor(map(E.entropy, 0.6, 1.0, 0, 10, true));
      for (let i=0;i<dustCount;i++) {
        dustStars.push(new DustStar(random(width), random(height*0.05, height*0.65), E.entropy));
      }

      // ====== 双葉・花（地点ごと最大3本 / 自然成長 / 無制限数） ======
      // 通常生成（控えめ）
      if (E.plantBand > 70 && random() < 0.35) {
        spawnPlantSmart(E.plantBand);
      }
      // 植物帯のピークで「ぶわっ」
      if (plantPeak.isDetected) {
        const burst = floor(random(3, 7)); // 3〜6本
        for (let i=0;i<burst;i++) spawnPlantSmart(E.plantBand);
      }

      // ====== ちょうちょ（小さく・少なめ・2000Hz以上） ======
      if ((E.bflyBand > 120 && random() < 0.012) || random() < 0.003) {
        butterflies.push(new Butterfly(random(width), random(height*0.35, height*0.75), 0.5)); // scaleBase=0.5
      }

      // ====== 流星（柔軟トリガ：音量/低域/超高域 いずれかが高め） ======
      const meteorTrig = (E.level > 0.18) || (E.bass > 130) || (E.ultra > 130);
      if (meteorTrig && meteors.length < 6 && random() < 0.25) {
        const dir = random([-1, 1]);
        const startX = (dir>0 ? random(width*0.05, width*0.45) : random(width*0.55, width*0.95));
        const startY = random(height*0.05, height*0.5);
        const vx = dir * random(7.5, 10.5);
        const vy = random(6.0, 9.0);
        meteors.push(new Meteor(startX, startY, vx, vy, floor(random(28, 50))));
      }

      // ====== 更新・描画 ======
      for (let i = dustStars.length-1; i>=0; i--) { dustStars[i].update(); dustStars[i].draw(silenceFade); if (dustStars[i].dead) dustStars.splice(i,1); }
      for (let i = meteors.length-1; i>=0; i--) { meteors[i].update(); meteors[i].draw(silenceFade); if (meteors[i].dead) meteors.splice(i,1); }
      for (let i = plants.length-1; i>=0; i--) { plants[i].update(); plants[i].draw(silenceFade); if (plants[i].dead) plants.splice(i,1); }
      for (let i = butterflies.length-1; i>=0; i--) { butterflies[i].update(); butterflies[i].draw(silenceFade); if (butterflies[i].dead) butterflies.splice(i,1); }

      if (silenceFade > 0.95) { /* 白線のみ */ }
    }

    // ====== Plant spawn helpers ======
    function xToBin(x){ return constrain(floor(x / BIN_W), 0, NUM_BINS-1); }
    function countPlantsInBin(bi){
      let c = 0;
      for (let p of plants){
        if (p.dead) continue;
        const b = xToBin(p.x);
        if (b === bi) c++;
      }
      return c;
    }
    function spawnPlantSmart(energy){
      // ランダムに位置を選びつつ、同一ビンで3本未満になるよう探す
      let tries = 10;
      while (tries-- > 0){
        const x = random(width);
        const bi = xToBin(x);
        if (countPlantsInBin(bi) < 3){
          const type = (random() < 0.55 ? 'sprout' : 'flower'); // 双葉多め
          plants.push(new Plant(x, type, energy));
          break;
        }
      }
    }

    // ======= クラス =======
    function easeOutCubic(t){ return 1 - pow(1 - t, 3); }
    function easeOutBack(t){ const c1 = 1.70158, c3 = c1 + 1; return 1 + c3*pow(t-1,3) + c1*pow(t-1,2); }

    class Plant {
      constructor(x, type, energy) {
        this.x = x;
        this.type = type; // 'sprout' or 'flower'
        this.life = 0;
        this.dead = false;

        // やや大きめ・双葉は低め
        const baseH = (type==='sprout') ? random(10, 18) : random(22, 44);
        const sizeK = map(energy, 70, 255, 0.9, 1.4, true);
        this.hTarget = baseH * sizeK;

        // 成長アニメ
        this.growFrames = floor(random(48, 90));   // 0.8〜1.5秒
        this.bloomStart = this.growFrames * 0.55;
        this.age = 0;
        this.maxAge = this.growFrames + floor(random(90, 160));

        // 見た目サイズ
        this.leafW = random(10, 16) * sizeK * (type==='sprout'?1.2:1.0);
        this.leafH = random(5.5, 8.0) * sizeK * (type==='sprout'?1.2:1.0);
        this.flowerR = random(7, 12) * sizeK;

        // 風揺れ
        this.swing = random(0.012, 0.022);
        this.seed = random(1000);
      }
      update() {
        this.age++;
        if (this.age > this.maxAge) this.dead = true;
      }
      draw(silence) {
        const y0 = baselineY;
        const t = constrain(this.age / this.growFrames, 0, 1);
        const grow = easeOutCubic(t);
        const sway = sin(frameCount * this.swing + this.seed) * 5 * (1 - silence);
        const stemH = this.hTarget * grow * (1 - silence*0.95);
        const topX = this.x + sway;
        const topY = y0 - stemH;

        // stem
        stroke(255); strokeWeight(1.8);
        line(this.x, y0, topX, topY);
        noStroke();

        if (this.type === 'flower') {
          // つぼみ→開花
          const bt = t < 0.001 ? 0 : constrain((this.age - this.bloomStart)/ (this.growFrames - this.bloomStart + 1), 0, 1);
          const open = easeOutBack(bt);
          const r = this.flowerR * (0.4 + 0.6 * open) * (1 - silence*0.9);
          push();
          translate(topX, topY);
          fill(255);
          for (let i=0;i<6;i++){
            const a = i * PI/3 + this.seed*0.2;
            const pr = r * 0.95;
            ellipse(cos(a)*pr, sin(a)*pr, pr*0.95, pr*0.95);
          }
          fill(255);
          circle(0,0, r*0.9);
          pop();
        } else {
          // 双葉：大きめ2枚葉
          const lr = easeOutBack(t);
          const lw = this.leafW * lr * (1 - silence*0.9);
          const lh = this.leafH * lr * (1 - silence*0.9);
          push();
          translate(topX, topY);
          fill(255);
          ellipse(-lw*0.7, 0, lw, lh);
          ellipse(+lw*0.7, 0, lw, lh);
          pop();
        }
      }
    }

    class Butterfly {
      constructor(x, y, scaleBase=0.5) { // 以前の約1/2サイズ
        this.x = x; this.y = y;
        this.life = 0; this.maxLife = 300 + random(120);
        this.dead = false;
        // ふわふわ動き（控えめ）
        this.vx = random(-0.5, 0.5);
        this.vy = random(-0.25, 0.25);
        this.phase = random(TWO_PI);
        // 見た目スケール（小さく）
        this.s = scaleBase * random(0.9, 1.1);
      }
      update() {
        this.life++;
        this.phase += 0.05;
        this.x += this.vx + sin(this.phase*1.6) * 0.6;
        this.y += this.vy + cos(this.phase*1.1) * 0.45;
        this.x = constrain(this.x, -20, width+20);
        this.y = constrain(this.y, height*0.25, baselineY - 12);
        if (this.life > this.maxLife) this.dead = true;
      }
      draw(silence) {
        const a = (1 - silence) * 220 * (1 - this.life/this.maxLife);
        push();
        translate(this.x, this.y);
        scale(this.s);
        noStroke();
        fill(255, a);
        const flap = 0.9 + sin(frameCount*0.45) * 0.30 * (1 - silence);
        push();
        scale(flap, 1);
        ellipse(-9, -2, 16, 12);
        ellipse(-8,  5, 14, 10);
        ellipse( 9, -2, 16, 12);
        ellipse( 8,  5, 14, 10);
        pop();
        rectMode(CENTER); rect(0, 0, 2.2, 12, 2);
        stroke(255, a); strokeWeight(1); noFill();
        bezier(-1, -6, -5, -10, -7, -12, -8, -13);
        bezier( 1, -6,  5, -10,  7, -12,  8, -13);
        pop();
      }
    }

    class DustStar {
      constructor(x, y, noiseIndex) {
        this.x = x; this.y = y;
        this.life = 0;
        this.maxLife = random(80, 180);
        this.size = map(noiseIndex, 0.6, 1.0, 0.9, 2.8, true) * random(0.8, 1.4);
        this.alpha = random(90, 180);
        this.dead = false;
      }
      update() { this.life++; if (this.life > this.maxLife) this.dead = true; }
      draw(silence) {
        const a = this.alpha * (1 - silence);
        fill(255, a);
        noStroke();
        circle(this.x, this.y, this.size);
      }
    }

    class Meteor {
      constructor(x, y, vx, vy, life) {
        this.x = x; this.y = y;
        this.vx = vx; this.vy = vy;
        this.life = 0; this.maxLife = life;
        this.dead = false;
        this.trail = [];
      }
      update() {
        this.life++;
        this.trail.push({x:this.x, y:this.y});
        if (this.trail.length > 20) this.trail.shift();
        this.x += this.vx; this.y += this.vy;
        if (this.life > this.maxLife) this.dead = true;
      }
      draw(silence) {
        const alpha = 230 * (1 - silence);
        noFill();
        for (let i=0;i<this.trail.length-1;i++) {
          const p1 = this.trail[i], p2 = this.trail[i+1];
          const a = alpha * (i / this.trail.length);
          stroke(255, a);
          strokeWeight(map(i, 0, this.trail.length-1, 1, 3.2));
          line(p1.x, p1.y, p2.x, p2.y);
        }
        noStroke();
        fill(255, alpha);
        ellipse(this.x, this.y, 4.5, 4.5);
      }
    }

    // ======= Recording (Canvas + Audio) =======
    async function startRecording() {
      if (mediaRecorder) return;
      const canvasStream = document.querySelector('canvas').captureStream(60);
      const ac = getAudioContext();
      if (!destNode) {
        destNode = ac.createMediaStreamDestination();
        try { p5.soundOut.output.connect(destNode); } catch(e){ console.warn('audio connect failed', e); }
      }
      const combined = new MediaStream([ ...canvasStream.getVideoTracks(), ...destNode.stream.getAudioTracks() ]);
      mediaRecorder = new MediaRecorder(combined, { mimeType: 'video/webm;codecs=vp9,opus' });
      recordedChunks = [];
      mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };
      mediaRecorder.onstop = e => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'visualizer_v5.webm';
        a.click();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
        mediaRecorder = null;
      };
      mediaRecorder.start();
    }

    async function stopRecording() {
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
    }
  </script>
</body>
</html>