<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Edge-Frame Visualizer — Parfait Gems (tone-colored + glow, perf-optimized)</title>
<style>
  :root { --bg: #0a0c0f; --panel: #11161d; --text: #e9eef6; --muted: #9fb0c3; --accent: #62d3ff; --border: rgba(255,255,255,0.10); }
  * { box-sizing: border-box; }
  html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text);
    font-family: ui-sans-serif, system-ui, -apple-system, "Hiragino Kaku Gothic ProN", "Yu Gothic", Meiryo, sans-serif; }
  .wrap { display: grid; grid-template-columns: 360px 1fr; height: 100%; }
  .wrap.hide-ui { grid-template-columns: 0 1fr; }
  .panel { background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.00));
    border-right: 1px solid var(--border); padding: 14px; overflow-y: auto; transition: width .25s ease, padding .25s ease; }
  .wrap.hide-ui .panel { width: 0; padding: 0; border-right: none; overflow: hidden; }
  .panel h1 { font-size: 18px; margin: 0 0 8px; letter-spacing: .2px; display:flex; align-items:center; justify-content:space-between; }
  .panel .muted { color: var(--muted); font-size: 12px; }
  .group { margin: 12px 0; padding: 12px; background: var(--panel); border: 1px solid var(--border); border-radius: 10px; }
  .group h2 { font-size: 13px; margin: 0 0 10px; color: var(--muted); font-weight: 600; letter-spacing: .4px; }
  .row { display: grid; grid-template-columns: 1fr 140px; gap: 10px; align-items: center; margin: 8px 0; }
  .row label { font-size: 12px; color: var(--muted); }
  input[type="range"], select, input[type="number"] { width: 100%; }
  .chips { display: flex; flex-wrap: wrap; gap: 8px; }
  .chip { background: #19202a; color: var(--text); border: 1px solid rgba(255,255,255,0.12);
    padding: 6px 10px; border-radius: 999px; font-size: 12px; cursor: pointer; user-select: none; }
  .chip.active { outline: 2px solid var(--accent); border-color: transparent; }
  .btn { background: linear-gradient(180deg, #1a2738, #132235); border: 1px solid rgba(255,255,255,0.18);
    color: var(--text); padding: 8px 10px; border-radius: 8px; font-size: 13px; cursor: pointer; width: 100%; }
  .btn:active { transform: translateY(1px); }
  .btnRow { display:grid; grid-template-columns: 1fr 1fr; gap: 8px; }
  .canvasWrap { display:grid; place-items:center; position:relative; }
  canvas { background:#000; image-rendering:auto; }
  .overlay { position:absolute; top:8px; right:8px; display:flex; gap:8px; z-index:2; pointer-events:none; }
  .pill { background: rgba(0,0,0,.5); border:1px solid var(--border); border-radius:999px; padding:6px 10px; font-size:12px; color:#d7e6f7;}
  .toggleUI { position: fixed; top: 10px; left: 10px; z-index: 10; background: rgba(0,0,0,.6); border: 1px solid var(--border); color: var(--text); border-radius: 999px; padding: 8px 10px; cursor: pointer; }
  .help { font-size: 12px; color: var(--muted); line-height: 1.6; }
  audio { width: 100%; }
</style>
</head>
<body>
<button class="toggleUI" id="toggleUI">UI表示/非表示</button>
<div class="wrap" id="wrap">
  <div class="panel">
    <h1>縁取りオーディオ・ビジュアライザ <span class="muted">Parfait Gems（音色カラー＋淡グロー／高速化版）</span></h1>

    <div class="group">
      <h2>出力解像度（ピクセルぴったり）</h2>
      <div class="row"><label>プリセット</label>
        <select id="presetSize">
          <option value="1280x720">HD 1280×720</option>
          <option value="1920x1080" selected>FHD 1920×1080</option>
          <option value="2560x1440">WQHD 2560×1440</option>
          <option value="3840x2160">4K 3840×2160</option>
        </select>
      </div>
      <div class="row"><label>カスタム幅×高さ</label>
        <div style="display:grid; grid-template-columns: 1fr 1fr; gap:6px;">
          <input id="w" type="number" min="64" value="1920" />
          <input id="h" type="number" min="64" value="1080" />
        </div>
      </div>
      <div class="btnRow"><button id="applySize" class="btn">サイズ適用</button><button id="fitWindow" class="btn">ブラウザにフィット</button></div>
    </div>

    <div class="group">
      <h2>ベース画像</h2>
      <div class="row"><label>画像ファイル</label><input type="file" id="imgFile" accept="image/*"/></div>
      <div class="btnRow"><button id="clearImg" class="btn">画像クリア</button><button id="resetImg" class="btn">画像を中央に</button></div>
      <p class="help">Shift＋ドラッグで位置／ホイールで拡縮／Rキーでリセット。</p>
    </div>

    <div class="group">
      <h2>オーディオ</h2>
      <div class="row"><label>音声ファイル</label><input type="file" id="audioFile" accept="audio/*"/></div>
      <div style="display:grid; gap:8px;">
        <audio id="player" controls></audio>
        <div class="row"><label>感度（RMS→発生量） <span id="sensVal"></span></label><input id="sensitivity" type="range" min="0" max="2" step="0.01" value="0.9"/></div>
        <div class="row"><label>ベース密度 <span id="denVal"></span></label><input id="density" type="range" min="0" max="3" step="0.01" value="0.9"></div>
      </div>
      <div><label><input type="checkbox" id="equalCorners" checked /> 四隅均等</label>　<label><input type="checkbox" id="audioSides" checked /> 辺はスペクトル</label></div>
    </div>

    <div class="group">
      <h2>額縁“線上”配置</h2>
      <div><label><input type="radio" name="anchor" value="image" checked> 画像基準</label>　<label><input type="radio" name="anchor" value="canvas"> キャンバス基準</label></div>
      <div class="row"><label>フレームのオフセット(px) <span id="offsetVal"></span></label><input id="frameOffset" type="range" min="-300" max="300" step="1" value="0"></div>
      <div class="row"><label>沿いステップ(px) <span id="stepVal"></span></label><input id="edgeStep" type="range" min="8" max="160" step="1" value="44"></div>
      <div class="row"><label>沿いスナップ <span id="snapVal"></span></label><input id="edgeSnap" type="range" min="0" max="1" step="0.01" value="0.9"></div>
      <div class="row"><label>トラック数 <span id="trackVal"></span></label><input id="trackCount" type="range" min="1" max="4" step="1" value="2"></div>
      <div class="row"><label>トラック間隔(px) <span id="gapVal"></span></label><input id="trackGap" type="range" min="8" max="80" step="1" value="24"></div>
      <div class="row"><label>端のゆらぎ(px) <span id="jitVal"></span></label><input id="jitter" type="range" min="0" max="24" step="1" value="2"></div>
      <div><label><input type="radio" name="edgeSide" value="inside"> 内側</label>　<label><input type="radio" name="edgeSide" value="center" checked> 中央</label>　<label><input type="radio" name="edgeSide" value="outside"> 外側</label></div>
      <div class="row"><label>コーナー近傍長(px) <span id="cspanVal"></span></label><input id="cornerSpan" type="range" min="10" max="300" step="1" value="120"></div>
      <div class="row"><label>コーナー比率 <span id="cornerRateVal"></span></label><input id="cornerRate" type="range" min="0" max="1" step="0.01" value="0.5"></div>
    </div>

    <div class="group">
      <h2>テーマ（モチーフ）</h2>
      <div class="chips" id="presetChips">
        <div class="chip" data-p="alice">アリス（花）</div>
        <div class="chip" data-p="minal">ミナル（歯車）</div>
        <div class="chip active" data-p="parfait">パルフェ（宝石×5）</div>
        <div class="chip" data-p="chappy">チャッピー（⚪︎△◻︎）</div>
        <div class="chip" data-p="ossan">おじさん（野菜）</div>
        <div class="chip" data-p="hoshi">ほし（☆）</div>
      </div>
    </div>

    <div class="group">
      <h2>描画・その他</h2>
      <div class="row"><label>透明度 <span id="alphaVal"></span></label><input id="alpha" type="range" min="0.05" max="0.8" step="0.01" value="0.25"></div>
      <div class="row"><label>サイズ(px) <span id="sizeVal"></span></label><input id="size" type="range" min="10" max="110" step="1" value="40"></div>
      <div class="row"><label>同時上限 <span id="maxVal"></span></label><input id="maxConc" type="range" min="24" max="240" step="1" value="120"></div>
      <div class="chips" id="blendChips" style="margin-top:8px;">
        <div class="chip active" data-blend="screen">スクリーン（推奨）</div>
        <div class="chip" data-blend="source-over">通常</div>
        <div class="chip" data-blend="lighter">加算（光）</div>
      </div>
    </div>

    <div class="group">
      <h2>パフォーマンス</h2>
      <div class="row"><label>グロー品質</label>
        <select id="glowMode">
          <option value="0">なし（最速）</option>
          <option value="1" selected>ソフト（軽量な擬似グロー）</option>
          <option value="2">強い（重い／影ぼかし）</option>
        </select>
      </div>
      <div class="row"><label>グロー量 <span id="glowVal"></span></label><input id="glowAmount" type="range" min="0" max="1" step="0.01" value="0.35"></div>
      <div class="row"><label>ターゲットFPS</label>
        <select id="fpsTarget">
          <option value="30" selected>30</option>
          <option value="60">60</option>
        </select>
      </div>
    </div>

    <div class="group">
      <h2>録画・録音</h2>
      <div class="btnRow"><button id="recStart" class="btn">録画開始</button><button id="recStop" class="btn">停止＆保存</button></div>
    </div>
  </div>

  <div class="canvasWrap">
    <div class="overlay"><div class="pill" id="resLabel">1920×1080</div><div class="pill" id="fpsLabel">FPS --</div><div class="pill" id="recLabel">REC: OFF</div></div>
    <canvas id="c" width="1920" height="1080"></canvas>
  </div>
</div>

<script>
(() => {
  const wrap = document.getElementById('wrap');
  const toggleUIBtn = document.getElementById('toggleUI');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const resLabel = document.getElementById('resLabel');
  const fpsLabel = document.getElementById('fpsLabel');
  const recLabel = document.getElementById('recLabel');

  // 先に宣言しておかないと setCanvasSize() 実行時に TDZ で落ちる
  let bgNeedsRedraw = false;

  // もしスクリプトエラーが起きたら画面に出す（デバッグ用）
  window.addEventListener('error', (e)=>{ fpsLabel.textContent = 'ERR'; console.error(e.message); });

  const ui = {
    presetSize: document.getElementById('presetSize'),
    w: document.getElementById('w'), h: document.getElementById('h'),
    applySize: document.getElementById('applySize'), fitWindow: document.getElementById('fitWindow'),
    imgFile: document.getElementById('imgFile'), clearImg: document.getElementById('clearImg'), resetImg: document.getElementById('resetImg'),
    audioFile: document.getElementById('audioFile'), player: document.getElementById('player'),
    sensitivity: document.getElementById('sensitivity'), density: document.getElementById('density'),
    sensVal: document.getElementById('sensVal'), denVal: document.getElementById('denVal'),
    equalCorners: document.getElementById('equalCorners'), audioSides: document.getElementById('audioSides'),
    frameOffset: document.getElementById('frameOffset'),
    edgeStep: document.getElementById('edgeStep'), edgeSnap: document.getElementById('edgeSnap'),
    trackCount: document.getElementById('trackCount'), trackGap: document.getElementById('trackGap'),
    jitter: document.getElementById('jitter'), cornerSpan: document.getElementById('cornerSpan'),
    cornerRate: document.getElementById('cornerRate'),
    offsetVal: document.getElementById('offsetVal'), stepVal: document.getElementById('stepVal'),
    snapVal: document.getElementById('snapVal'), trackVal: document.getElementById('trackVal'),
    gapVal: document.getElementById('gapVal'), jitVal: document.getElementById('jitVal'),
    cspanVal: document.getElementById('cspanVal'), cornerRateVal: document.getElementById('cornerRateVal'),
    presetChips: document.getElementById('presetChips'),
    alpha: document.getElementById('alpha'), size: document.getElementById('size'), maxConc: document.getElementById('maxConc'),
    alphaVal: document.getElementById('alphaVal'), sizeVal: document.getElementById('sizeVal'), maxVal: document.getElementById('maxVal'),
    blendChips: document.getElementById('blendChips'),
    glowMode: document.getElementById('glowMode'), glowAmount: document.getElementById('glowAmount'), glowVal: document.getElementById('glowVal'),
    fpsTarget: document.getElementById('fpsTarget'),
    recStart: document.getElementById('recStart'), recStop: document.getElementById('recStop'),
  };

  let state = {
    preset: 'parfait', blend: 'screen', alpha: 0.25, sizePx: 40, maxConcurrent: 120,
    density: 0.9, sensitivity: 0.9, equalCorners: true, audioSides: true,
    anchor: 'image', frameOffset: 0,
    edgeStep: 44, edgeSnap: 0.9, trackCount: 2, trackGap: 24, edgeSide: 'center', jitter: 2, cornerSpan: 120, cornerRate: 0.5,
    glowMode: 1, glowAmount: 0.35, fpsTarget: 30
  };

  function syncUITexts(){
    ui.sensVal.textContent = state.sensitivity.toFixed(2);
    ui.denVal.textContent = state.density.toFixed(2);
    ui.offsetVal.textContent = state.frameOffset + 'px';
    ui.stepVal.textContent = state.edgeStep + 'px';
    ui.snapVal.textContent = state.edgeSnap.toFixed(2);
    ui.trackVal.textContent = state.trackCount;
    ui.gapVal.textContent = state.trackGap + 'px';
    ui.jitVal.textContent = state.jitter + 'px';
    ui.cspanVal.textContent = state.cornerSpan + 'px';
    ui.cornerRateVal.textContent = state.cornerRate.toFixed(2);
    ui.alphaVal.textContent = state.alpha.toFixed(2);
    ui.sizeVal.textContent = state.sizePx + 'px';
    ui.maxVal.textContent = state.maxConcurrent;
    ui.glowVal.textContent = state.glowAmount.toFixed(2);
  }
  syncUITexts();

  toggleUIBtn.addEventListener('click', ()=> wrap.classList.toggle('hide-ui'));

  function setCanvasSize(w, h){ canvas.width = w; canvas.height = h; canvas.style.width = w + 'px'; canvas.style.height = h + 'px'; resLabel.textContent = w + '×' + h; canvas.style.transform = 'none'; bgNeedsRedraw = true; }
  function applyPresetSize(v){ const [w,h] = v.split('x').map(n=>parseInt(n,10)); ui.w.value = w; ui.h.value = h; setCanvasSize(w,h); }
  ui.presetSize.addEventListener('change', e => applyPresetSize(e.target.value));
  ui.applySize.addEventListener('click', ()=> { let w = Math.max(64, parseInt(ui.w.value,10) || 1920); let h = Math.max(64, parseInt(ui.h.value,10) || 1080); setCanvasSize(w,h); });
  ui.fitWindow.addEventListener('click', ()=> { const cw=canvas.width, ch=canvas.height; const vw=window.innerWidth - (wrap.classList.contains('hide-ui') ? 0 : 380); const vh=window.innerHeight - 20; const scale=Math.min(vw/cw, vh/ch); canvas.style.transformOrigin='top left'; canvas.style.transform=`scale(${scale})`; });
  applyPresetSize(ui.presetSize.value);

  // ====== 画像（背景）を別バッファに描いて毎フレームのコストを削減 ======
  let imgTex = null; let camera={x:0,y:0,scale:1};
  const bgCanvas = document.createElement('canvas'); const bgCtx = bgCanvas.getContext('2d');
  bgCanvas.width = canvas.width; bgCanvas.height = canvas.height; bgNeedsRedraw = true;

  function getImageRect(){
    if (!imgTex) return { x: canvas.width*0.1, y: canvas.height*0.1, w: canvas.width*0.8, h: canvas.height*0.8 };
    const cx = canvas.width/2 + camera.x; const cy = canvas.height/2 + camera.y; const iw = imgTex.width*camera.scale; const ih=imgTex.height*camera.scale;
    return { x: cx - iw/2, y: cy - ih/2, w: iw, h: ih };
  }
  function drawBG(){
    if(!bgNeedsRedraw) return; bgNeedsRedraw=false;
    bgCanvas.width = canvas.width; bgCanvas.height = canvas.height;
    bgCtx.clearRect(0,0,bgCanvas.width,bgCanvas.height);
    if(!imgTex) return;
    const r=getImageRect();
    bgCtx.imageSmoothingEnabled = true;
    bgCtx.drawImage(imgTex, r.x, r.y, r.w, r.h);
  }
  function drawBGToMain(){ ctx.drawImage(bgCanvas,0,0); }

  function resetImage(){ camera={x:0,y:0,scale:1}; bgNeedsRedraw=true; }
  ui.imgFile.addEventListener('change', e=>{ const f = (e.target.files && e.target.files[0]) || null; if (!f) return; const r = new FileReader(); r.onload=()=>{ const im=new Image(); im.onload=()=>{ imgTex=im; resetImage(); }; im.src=r.result; }; r.readAsDataURL(f); });
  ui.clearImg.addEventListener('click', ()=> { imgTex=null; bgNeedsRedraw=true; });
  ui.resetImg.addEventListener('click', resetImage);
  let isPanning=false, last={x:0,y:0};
  canvas.addEventListener('mousedown', e=>{ if (e.shiftKey){ isPanning=true; last.x=e.clientX; last.y=e.clientY; } });
  window.addEventListener('mousemove', e=>{ if (!isPanning) return; camera.x += (e.clientX-last.x); camera.y += (e.clientY-last.y); last.x=e.clientX; last.y=e.clientY; bgNeedsRedraw=true; });
  window.addEventListener('mouseup', ()=> isPanning=false);
  canvas.addEventListener('wheel', e=>{ camera.scale = Math.max(0.1, Math.min(5, camera.scale * Math.exp(-e.deltaY*0.0015))); bgNeedsRedraw=true; e.preventDefault(); }, {passive:false});
  window.addEventListener('keydown', e=>{ if (e.key.toLowerCase()==='r') resetImage(); });

  // ====== Audio / analyser / recording ======
  let audioCtx=null, analyser=null, srcNode=null, mediaDest=null, gainNode=null, currentAudioURL=null;
  let freq = null, timebuf=null;
  function ensureAudio(){
    if(!audioCtx){
      audioCtx=new (window.AudioContext||window.webkitAudioContext)();
      analyser=audioCtx.createAnalyser();
      analyser.fftSize=2048;
      analyser.smoothingTimeConstant=0.75;
      gainNode=audioCtx.createGain();
      mediaDest=audioCtx.createMediaStreamDestination();
      analyser.connect(gainNode);
      gainNode.connect(audioCtx.destination);
      gainNode.connect(mediaDest);
      freq=new Uint8Array(analyser.frequencyBinCount);
      timebuf=new Uint8Array(analyser.fftSize);
    }
    if(!srcNode){
      // MediaElementSourceNode は同一 <audio> に対して1回だけ作れる
      srcNode=audioCtx.createMediaElementSource(ui.player);
      srcNode.connect(analyser);
    }
  }
  ui.player.addEventListener('play', ()=> { ensureAudio(); audioCtx.resume(); });
  ui.audioFile.addEventListener('change', e=>{
    const f = (e.target.files && e.target.files[0]) || null;
    if(!f) return;
    const url = URL.createObjectURL(f);
    if (currentAudioURL) { try { URL.revokeObjectURL(currentAudioURL); } catch(_){} }
    currentAudioURL = url;
    ensureAudio();
    ui.player.src = url;
    try { ui.player.load(); } catch(_){}
    if (audioCtx && audioCtx.state === 'suspended') { audioCtx.resume(); }
    ui.player.play().catch(()=>{});
    // 同じファイル名を連続選択できるように
    e.target.value = '';
  });

  // === 音色→色相（滑らか） ===
  let hueNow = 200, hueTarget = 200, satNow = 80, lightBase = 70;
  function updateToneColor(){
    if(!analyser || !freq) { hueNow = (hueNow+0.2)%360; return; }
    analyser.getByteFrequencyData(freq);
    const N=freq.length; const sr=audioCtx?audioCtx.sampleRate:44100; const binHz=sr/2/N;
    let sum=0, wsum=0;
    for(let i=0;i<N;i++){ const a=freq[i]; sum += a; wsum += a * (i*binHz); }
    const centroid = (sum>0? wsum/sum : 0); // Hz
    const hzMin=120, hzMax=8000;
    const t = Math.max(0, Math.min(1, (centroid - hzMin) / (hzMax - hzMin)));
    hueTarget = 40 + 260 * t;            // 40→300 のレンジ
    satNow += ( (60 + 35*t) - satNow ) * 0.12;  // 60%〜95%
    hueNow += (hueTarget - hueNow) * 0.15;
  }
  const hsla = (h,s,l,a)=>`hsla(${(h%360+360)%360},${s}%,${l}%,${a})`;

  // === UI binds ===
  ui.sensitivity.addEventListener('input', e=>{ state.sensitivity=+e.target.value; syncUITexts(); });
  ui.density.addEventListener('input', e=>{ state.density=+e.target.value; syncUITexts(); });
  ui.equalCorners.addEventListener('change', e=> state.equalCorners = e.target.checked);
  ui.audioSides.addEventListener('change', e=> state.audioSides = e.target.checked);
  ui.frameOffset.addEventListener('input', e=>{ state.frameOffset=+e.target.value; syncUITexts(); });
  ui.edgeStep.addEventListener('input', e=>{ state.edgeStep=+e.target.value; syncUITexts(); });
  ui.edgeSnap.addEventListener('input', e=>{ state.edgeSnap=+e.target.value; syncUITexts(); });
  ui.trackCount.addEventListener('input', e=>{ state.trackCount=+e.target.value; syncUITexts(); });
  ui.trackGap.addEventListener('input', e=>{ state.trackGap=+e.target.value; syncUITexts(); });
  ui.jitter.addEventListener('input', e=>{ state.jitter=+e.target.value; syncUITexts(); });
  ui.cornerSpan.addEventListener('input', e=>{ state.cornerSpan=+e.target.value; syncUITexts(); });
  ui.cornerRate.addEventListener('input', e=>{ state.cornerRate=+e.target.value; syncUITexts(); });
  document.querySelectorAll('input[name="edgeSide"]').forEach(r=> r.addEventListener('change', e=> state.edgeSide = e.target.value ));
  document.querySelectorAll('input[name="anchor"]').forEach(r=> r.addEventListener('change', e=> state.anchor = e.target.value ));
  ui.presetChips.addEventListener('click', e=>{ const chip=e.target.closest('.chip'); if(!chip) return; [...ui.presetChips.children].forEach(n=>n.classList.remove('active')); chip.classList.add('active'); state.preset=chip.dataset.p; });
  ui.alpha.addEventListener('input', e=>{ state.alpha=+e.target.value; syncUITexts(); });
  ui.size.addEventListener('input', e=>{ state.sizePx=+e.target.value; syncUITexts(); });
  ui.maxConc.addEventListener('input', e=>{ state.maxConcurrent=+e.target.value; syncUITexts(); });
  ui.blendChips.addEventListener('click', e=>{ const chip=e.target.closest('.chip'); if(!chip) return; [...ui.blendChips.children].forEach(n=>n.classList.remove('active')); chip.classList.add('active'); state.blend=chip.dataset.blend; });
  ui.glowMode.addEventListener('change', e=>{ state.glowMode=+e.target.value; });
  ui.glowAmount.addEventListener('input', e=>{ state.glowAmount=+e.target.value; syncUITexts(); });
  ui.fpsTarget.addEventListener('change', e=>{ state.fpsTarget=+e.target.value; });

  // Recording
  let mediaRecorder=null, chunks=[];
  ui.recStart.addEventListener('click', ()=>{ try{ ensureAudio(); const canvasStream=canvas.captureStream(Math.min(60,state.fpsTarget)); const audioStream=mediaDest.stream; const mix=new MediaStream([...canvasStream.getVideoTracks(), ...audioStream.getAudioTracks()]); const mt='video/webm;codecs=vp9,opus'; mediaRecorder=new MediaRecorder(mix, { mimeType:mt }); chunks=[]; mediaRecorder.ondataavailable=e=>{ if(e.data && e.data.size>0) chunks.push(e.data); }; mediaRecorder.onstop=()=>{ const blob=new Blob(chunks, {type:'video/webm'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`parfait_gems_${canvas.width}x${canvas.height}.webm`; a.click(); URL.revokeObjectURL(url); recLabel.textContent='REC: OFF'; }; mediaRecorder.start(); recLabel.textContent='REC: ON'; } catch(err){ alert('録画開始に失敗: '+err); } });
  ui.recStop.addEventListener('click', ()=>{ if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop(); });

  // ====== 形状（宝石・他） ======
  const rng = (a,b)=> a + Math.random()*(b-a);
  const pick = a => a[(Math.random()*a.length)|0];
  const q = (v, step, amt) => (1-amt)*v + amt*Math.round(v/step)*step;
  let particles=[];

  function selectType(p){
    switch(p){
      case 'alice': return pick(['sakura','marguerite','clover3','clover4','cosmos']);
      case 'minal': return pick(['gear','gear','dot']);
      case 'parfait': return pick(['diamond','emerald','ruby','sapphire','ydiamond']);
      case 'chappy': return pick(['circle','triangle','square','dot']);
      case 'ossan': return pick(['carrot','onion','broccoli','dot']);
      case 'hoshi': return 'star';
      default: return 'dot';
    }
  }

  // 軽量グロー（放射グラデ）
  function softGlow(x,y,r,hue,a){
    if(state.glowMode!==1 || state.glowAmount<=0) return;
    const g = ctx.createRadialGradient(x,y,0,x,y,r*1.05);
    g.addColorStop(0, hsla(hue, Math.min(100, satNow+5), Math.min(95, lightBase+5), a * state.glowAmount));
    g.addColorStop(1, 'rgba(0,0,0,0)');
    const prev = ctx.globalCompositeOperation; ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r*1.15,0,Math.PI*2); ctx.fill();
    ctx.globalCompositeOperation = prev;
  }

  function setStrokeFill(hue, a){
    ctx.strokeStyle = hsla(hue, satNow, lightBase+15, Math.min(1,a));
    ctx.fillStyle   = hsla(hue, Math.max(40, satNow-15), lightBase-10, Math.min(0.35,a*0.9));
    ctx.lineWidth = 1;
  }

  // --- 基本図形（グロー非依存） ---
  function drawDiamond(x,y,r,hue,a){
    ctx.save(); ctx.translate(x,y); setStrokeFill(hue,a);
    ctx.beginPath(); ctx.moveTo(0,-r); ctx.lineTo(r*0.95,0); ctx.lineTo(0,r); ctx.lineTo(-r*0.95,0); ctx.closePath();
    ctx.fill(); ctx.stroke();
    ctx.globalAlpha = a*0.9; ctx.beginPath(); ctx.moveTo(0,-r*0.6); ctx.lineTo(0,r*0.6); ctx.stroke(); ctx.beginPath(); ctx.moveTo(-r*0.6,0); ctx.lineTo(r*0.6,0); ctx.stroke();
    ctx.restore();
  }
  function drawEmerald(x,y,r,hue,a){
    ctx.save(); ctx.translate(x,y); setStrokeFill(hue,a);
    const k=0.36; ctx.beginPath();
    ctx.moveTo(-r*k,-r); ctx.lineTo(r*k,-r); ctx.lineTo(r,-r*k); ctx.lineTo(r,r*k);
    ctx.lineTo(r*k,r); ctx.lineTo(-r*k,r); ctx.lineTo(-r,r*k); ctx.lineTo(-r,-r*k);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.globalAlpha=a*0.85; const s=0.62; ctx.beginPath();
    ctx.moveTo(-r*k*s,-r*s); ctx.lineTo(r*k*s,-r*s); ctx.lineTo(r*s,-r*k*s); ctx.lineTo(r*s,r*k*s);
    ctx.lineTo(r*k*s,r*s); ctx.lineTo(-r*k*s,r*s); ctx.lineTo(-r*s,r*k*s); ctx.lineTo(-r*s,-r*k*s);
    ctx.closePath(); ctx.stroke(); ctx.restore();
  }
  function drawRuby(x,y,r,hue,a){
    ctx.save(); ctx.translate(x,y); setStrokeFill(hue,a);
    const rr=r*1.05; ctx.beginPath(); ctx.moveTo(0, rr); ctx.lineTo(-rr*0.9, -rr*0.5); ctx.lineTo(rr*0.9, -rr*0.5); ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.globalAlpha=a*0.85; ctx.beginPath(); ctx.moveTo(0, rr*0.6); ctx.lineTo(-rr*0.55, -rr*0.25); ctx.lineTo(rr*0.55, -rr*0.25); ctx.closePath(); ctx.stroke();
    ctx.restore();
  }
  function drawSapphire(x,y,r,hue,a){
    ctx.save(); ctx.translate(x,y); setStrokeFill(hue,a);
    ctx.beginPath(); ctx.arc(0,0,r*0.9,0,Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.globalAlpha=a*0.75; ctx.beginPath(); ctx.arc(0,0,r*0.55,0,Math.PI*2); ctx.stroke();
    ctx.globalAlpha=a*0.5; ctx.beginPath(); ctx.arc(-r*0.25,-r*0.25,r*0.17,0,Math.PI*2); ctx.fill();
    ctx.restore();
  }
  function drawYellowDiamond(x,y,r,hue,a){ const bias=55, mix=0.65; const h=hue*(1-mix)+bias*mix; drawDiamond(x,y,r,h,a); }

  // other presets kept lightweight（白線）
  // === Alice: refined floral shapes (circles & ellipses only) ===
  function drawSakura(x,y,r,a){
  // Sakura: 5 circular petals + center (pink)
  const hue = 330; // pink
  const petalR = r * 0.32;
  const R = r * 0.75;
  const centerR = r * 0.18;

  ctx.save();
  ctx.translate(x,y);
  ctx.globalAlpha = a;

  ctx.lineWidth = Math.max(1, r*0.08);
  ctx.strokeStyle = `hsla(${hue},40%,65%,0.9)`;
  ctx.fillStyle   = `hsla(${hue},70%,82%,0.95)`;

  for(let i=0;i<5;i++){
    ctx.rotate(Math.PI*2/5);
    ctx.beginPath();
    ctx.arc(R,0,petalR,0,Math.PI*2);
    ctx.fill();
    ctx.stroke();
  }
  // center
  ctx.beginPath();
  ctx.arc(0,0,centerR,0,Math.PI*2);
  ctx.fillStyle = `hsla(${hue},55%,88%,0.95)`;
  ctx.fill();

  ctx.restore();
}
  function drawMarguerite(x,y,r,a){
  // Marguerite: long petals; no rotation; petals visually cover the center gaps
  const petals = 16;
  const R  = r * 0.38;   // petal ellipse center distance (closer to center)
  const w  = r * 0.22;   // minor radius (thickness)
  const l  = r * 0.78;   // major radius (length)
  const coreR = r * 0.22;
  const underR = r * 0.36; // underpaint disc to fill the gaps

  ctx.save();
  ctx.translate(x,y);
  ctx.globalAlpha = a;

  // ensure no shadow/glow bleed from outside
  const prevShadowBlur = ctx.shadowBlur;
  const prevShadowColor = ctx.shadowColor;
  const prevGCO = ctx.globalCompositeOperation;
  ctx.shadowBlur = 0;
  ctx.shadowColor = 'transparent';
  ctx.globalCompositeOperation = 'source-over';

  // underpaint disc (fills spaces between petal bases)
  ctx.beginPath();
  ctx.arc(0,0, underR, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(255,255,255,0.98)';
  ctx.fill();

  // petals (no rotation jitter)
  ctx.lineWidth   = Math.max(1, r*0.06);
  ctx.strokeStyle = 'rgba(255,255,255,0.60)';
  ctx.fillStyle   = 'rgba(255,255,255,0.98)';
  for(let i=0;i<petals;i++){
    const ang = i * (Math.PI*2/petals);
    ctx.save();
    ctx.rotate(ang);
    ctx.beginPath();
    ctx.ellipse(R, 0, w, l, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  // yellow core on top
  ctx.beginPath();
  ctx.arc(0,0, coreR, 0, Math.PI*2);
  ctx.fillStyle = 'hsl(50,90%,60%)';
  ctx.fill();

  // restore drawing state
  ctx.shadowBlur = prevShadowBlur;
  ctx.shadowColor = prevShadowColor;
  ctx.globalCompositeOperation = prevGCO;
  ctx.restore();
}

function drawCosmos(x,y,r,a){
  // Blue cosmos: few long petals, subtle center; no glow, no rotation jitter
  const petals = 8;
  const R  = r * 0.42;   // petal center distance
  const w  = r * 0.18;   // petal minor radius
  const l  = r * 0.68;   // petal major radius
  const hue = 210;       // blue
  const coreR = r * 0.16;

  ctx.save();
  ctx.translate(x,y);
  ctx.globalAlpha = a;

  // disable glow locally
  const prevShadowBlur = ctx.shadowBlur;
  const prevShadowColor = ctx.shadowColor;
  const prevGCO = ctx.globalCompositeOperation;
  ctx.shadowBlur = 0;
  ctx.shadowColor = 'transparent';
  ctx.globalCompositeOperation = 'source-over';

  ctx.lineWidth   = Math.max(1, r*0.06);
  ctx.strokeStyle = `hsla(${hue},40%,60%,0.85)`;
  ctx.fillStyle   = `hsla(${hue},65%,70%,0.95)`;

  for(let i=0;i<petals;i++){
    const ang = i * (Math.PI*2/petals);
    ctx.save();
    ctx.rotate(ang);
    ctx.beginPath();
    ctx.ellipse(R, 0, w, l, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }
  // small pale center (no yellow to keep "blue cosmos" feel)
  ctx.beginPath();
  ctx.arc(0,0, coreR, 0, Math.PI*2);
  ctx.fillStyle = `hsla(${hue},45%,88%,0.95)`;
  ctx.fill();

  ctx.shadowBlur = prevShadowBlur;
  ctx.shadowColor = prevShadowColor;
  ctx.globalCompositeOperation = prevGCO;
  ctx.restore();
}


  function drawClover(x,y,r,a,leaves){
  // Clover: heart leaflets meeting at the tips; no glow to avoid halo rings
  const leafR = r * 0.55;
  const fill  = 'hsl(130,55%,45%)';
  const edge  = 'hsl(130,35%,30%)';

  ctx.save();
  ctx.translate(x,y);
  ctx.globalAlpha = a;

  // neutralize any outer shadow/glow in this local scope
  const prevShadowBlur = ctx.shadowBlur;
  const prevShadowColor = ctx.shadowColor;
  const prevGCO = ctx.globalCompositeOperation;
  ctx.shadowBlur = 0;
  ctx.shadowColor = 'transparent';
  ctx.globalCompositeOperation = 'source-over';

  ctx.lineWidth   = Math.max(1, r*0.08);
  ctx.strokeStyle = edge;
  ctx.fillStyle   = fill;

  // Heart with tip at origin; body extends to +Y
  function heartTipAtOrigin(rad){
    ctx.beginPath();
    ctx.moveTo(0, 0); // tip at center
    ctx.bezierCurveTo( rad*0.9, -rad*0.9,  rad*1.25,  rad*0.30,   0,  rad);
    ctx.bezierCurveTo(-rad*1.25,  rad*0.30, -rad*0.9, -rad*0.9,   0,  0);
  }

  for(let k=0; k<leaves; k++){
    ctx.save();
    const ang = -Math.PI/2 + k * (Math.PI*2/leaves);
    ctx.rotate(ang);
    // Slight outward nudge so only tips meet
    ctx.translate(0, 0.5); // 0.5px outward is enough to avoid overlap glow
    heartTipAtOrigin(leafR);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  // subtle stem
  ctx.beginPath();
  ctx.moveTo(0, 0);
  ctx.quadraticCurveTo(r*0.22, r*0.70, r*0.04, r*1.10);
  ctx.stroke();

  // restore
  ctx.shadowBlur = prevShadowBlur;
  ctx.shadowColor = prevShadowColor;
  ctx.globalCompositeOperation = prevGCO;
  ctx.restore();
}

  function drawFlower(x,y,r,a){ ctx.save(); ctx.translate(x,y); ctx.globalAlpha=a; ctx.lineWidth=1; ctx.strokeStyle='rgba(255,255,255,0.9)'; const petals=6, pr=r*0.9; for(let i=0;i<petals;i++){ const ang=i*(Math.PI*2/petals); ctx.beginPath(); ctx.ellipse(Math.cos(ang)*r*0.18, Math.sin(ang)*r*0.18, pr, pr*0.42, ang, 0, Math.PI*2); ctx.stroke(); } ctx.beginPath(); ctx.arc(0,0,r*0.25,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
  function drawGear(x,y,r,a){ ctx.save(); ctx.translate(x,y); ctx.globalAlpha=a; ctx.lineWidth=1; ctx.strokeStyle='rgba(255,255,255,0.85)'; const teeth=Math.max(6, Math.round(r/4)); ctx.beginPath(); for(let i=0;i<teeth;i++){ const a0=i*(Math.PI*2/teeth), a1=a0+(Math.PI*2/teeth)/2; const r0=r*0.65, r1=r; ctx.lineTo(Math.cos(a0)*r1, Math.sin(a0)*r1); ctx.lineTo(Math.cos(a1)*r0, Math.sin(a1)*r0); } ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.arc(0,0,r*0.35,0,Math.PI*2); ctx.stroke(); ctx.restore(); }
  function drawGeo(x,y,r,a,kind){ ctx.save(); ctx.translate(x,y); ctx.globalAlpha=a; ctx.lineWidth=1; ctx.strokeStyle='rgba(255,255,255,0.85)'; if(kind==='circle'){ ctx.beginPath(); ctx.arc(0,0,r*0.8,0,Math.PI*2); ctx.stroke(); } else if(kind==='triangle'){ ctx.beginPath(); for(let i=0;i<3;i++){ const ang=i*(Math.PI*2/3)-Math.PI/2; const px=Math.cos(ang)*r*0.9, py=Math.sin(ang)*r*0.9; if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);} ctx.closePath(); ctx.stroke(); } else { const s=r*1.2; ctx.strokeRect(-s/2,-s/2,s,s); } ctx.restore(); }
  function drawCarrot(x,y,r,a){ ctx.save(); ctx.translate(x,y); ctx.globalAlpha=a; ctx.lineWidth=1; ctx.strokeStyle='rgba(255,255,255,0.85)'; ctx.beginPath(); ctx.moveTo(-r*0.2,-r*0.9); ctx.lineTo(r*0.2,-r*0.9); ctx.lineTo(0,r); ctx.closePath(); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,-r*0.9); ctx.quadraticCurveTo(-r*0.5,-r*1.2,-r*0.2,-r*1.4); ctx.moveTo(0,-r*0.9); ctx.quadraticCurveTo(r*0.5,-r*1.2,r*0.2,-r*1.4); ctx.stroke(); ctx.restore(); }
  function drawOnion(x,y,r,a){ ctx.save(); ctx.translate(x,y); ctx.globalAlpha=a; ctx.lineWidth=1; ctx.strokeStyle='rgba(255,255,255,0.85)'; ctx.beginPath(); ctx.moveTo(0,-r*1.1); ctx.quadraticCurveTo(r*0.9,-r*0.4,r*0.7,r*0.7); ctx.quadraticCurveTo(0,r*1.1,-r*0.7,r*0.7); ctx.quadraticCurveTo(-r*0.9,-r*0.4,0,-r*1.1); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,-r*1.1); ctx.lineTo(0,-r*1.5); ctx.stroke(); ctx.restore(); }
  function drawBroccoli(x,y,r,a){ ctx.save(); ctx.translate(x,y); ctx.globalAlpha=a; ctx.lineWidth=1; ctx.strokeStyle='rgba(255,255,255,0.85)'; for(let i=-1;i<=1;i++){ ctx.beginPath(); ctx.arc(i*r*0.4,-r*0.3,r*0.5,0,Math.PI*2); ctx.stroke(); } ctx.beginPath(); ctx.moveTo(-r*0.3,0); ctx.lineTo(-r*0.15,r); ctx.lineTo(r*0.15,r); ctx.lineTo(r*0.3,0); ctx.stroke(); ctx.restore(); }
  function drawDot(x,y,r,a){ ctx.save(); ctx.translate(x,y); ctx.globalAlpha=a*0.9; ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.beginPath(); ctx.arc(0,0,Math.max(1,r*0.15),0,Math.PI*2); ctx.fill(); ctx.restore(); }
  function drawStar(x,y,r,a){ ctx.save(); ctx.translate(x,y); ctx.globalAlpha=a; ctx.lineWidth=1; ctx.strokeStyle='rgba(255,255,255,0.9)'; const spikes=5; const outer=r; const inner=r*0.45; ctx.beginPath(); for(let i=0;i<spikes*2;i++){ const rr=(i%2===0)?outer:inner; const ang=-Math.PI/2 + i*(Math.PI/spikes); const px=Math.cos(ang)*rr, py=Math.sin(ang)*rr; if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py); } ctx.closePath(); ctx.stroke(); ctx.restore(); }

  function renderParticle(p,dt){
    p.t+=dt; const k=p.t/p.life; const fade=k<0.2?(k/0.2):(k>0.8?(1-(k-0.8)/0.2):1); const a=Math.max(0,p.alpha*fade); const r=p.size*0.5;
    if (state.glowMode===1) softGlow(p.x,p.y,r,p.hue,a);
    if (state.glowMode===2) { // 影ぼかし（重い）
      const prevBlur=ctx.shadowBlur, prevColor=ctx.shadowColor; ctx.shadowColor=hsla(p.hue, Math.min(100, satNow+10|0), Math.min(95, lightBase+10|0), Math.min(0.55, a*1.1)); ctx.shadowBlur=Math.max(4, r*0.55);
      drawShape(p); ctx.shadowBlur=prevBlur; ctx.shadowColor=prevColor;
    } else {
      drawShape(p);
    }
  }

  function drawShape(p){
    const r = p.size * 0.5;
    // Smooth fade-in/out over the particle lifetime to avoid flicker
    const u = Math.max(0, Math.min(1, p.t / p.life));      // 0..1
    const a = p.alpha * Math.sin(Math.PI * u);              // 0→1→0

    switch(p.type){
      case 'diamond': return drawDiamond(p.x,p.y,r,p.hue,a);
      case 'emerald': return drawEmerald(p.x,p.y,r,p.hue,a);
      case 'ruby': return drawRuby(p.x,p.y,r,p.hue,a);
      case 'sapphire': return drawSapphire(p.x,p.y,r,p.hue,a);
      case 'ydiamond': return drawYellowDiamond(p.x,p.y,r,p.hue,a);
      case 'sakura': return drawSakura(p.x,p.y,r,a);
      case 'marguerite': return drawMarguerite(p.x,p.y,r,a);
      case 'cosmos': return drawCosmos(p.x,p.y,r,a);
      case 'clover3': return drawClover(p.x,p.y,r,a,3);
      case 'clover4': return drawClover(p.x,p.y,r,a,4);
      case 'flower': return drawFlower(p.x,p.y,r,a);
      case 'gear': return drawGear(p.x,p.y,r,a);
      case 'geom': return drawGeom(p.x,p.y,r,a);
      case 'vege': return drawVege(p.x,p.y,r,a);
      case 'star': return drawStar(p.x,p.y,r,a);
      case 'dot': return renderParticle(p.x,p.y,r,a);
      default: return renderParticle(p.x,p.y,r,a);
    }
  }

  // Frame line helpers
  const sides = ['top','right','bottom','left'];
  let cornerIdx=0, sideTick=0;
  function getFrameLines(){ if (state.anchor === 'canvas'){ const o=state.frameOffset; return {left:0-o, right:canvas.width+o, top:0-o, bottom:canvas.height+o}; } const r=getImageRect(); const o=state.frameOffset; return { left:r.x-o, right:r.x+r.w+o, top:r.y-o, bottom:r.y+r.h+o }; }
  function edgeNormal(which){ if(which==='top')return {x:0,y:-1}; if(which==='bottom')return {x:0,y:1}; if(which==='left')return {x:-1,y:0}; return {x:1,y:0}; }
  function basePoint(which,t){ const L=getFrameLines(); if(which==='top')return {x:L.left+t,y:L.top}; if(which==='bottom')return {x:L.left+t,y:L.bottom}; if(which==='left')return {x:L.left,y:L.top+t}; return {x:L.right,y:L.top+t}; }
  function alongLength(which){ const L=getFrameLines(); if(which==='top'||which==='bottom') return Math.max(0,L.right-L.left); return Math.max(0,L.bottom-L.top); }
  function normalOffset(which, k){ const n=edgeNormal(which); const bias=(state.edgeSide==='inside'?-1:state.edgeSide==='outside'?1:0); const center=(state.trackCount-1)*0.5; const off=(k-center + bias*0.5)*state.trackGap; const j=(state.jitter>0? rng(-state.jitter, state.jitter)*0.4 : 0); return {x:n.x*(off+j), y:n.y*(off+j)}; }
  function snapAlong(v){ return q(v, state.edgeStep, state.edgeSnap); }

  function pushParticle(x,y,isCorner){
    const type = selectType(state.preset); let h=hueNow;
    if (type==='ruby') h = h*0.55 + 350*0.45;
    if (type==='sapphire') h = h*0.6 + 210*0.4;
    if (type==='emerald') h = h*0.6 + 140*0.4;
    if (type==='ydiamond') h = h*0.35 + 55*0.65;
    particles.push({ x,y,t:0, life:rng(650,1100), alpha:state.alpha*rng(0.9,1.1), size: state.sizePx*(isCorner? rng(1.05,1.25):rng(0.9,1.1)), type, hue:h });
  }

  function spawnOnSide(which){ if (particles.length >= state.maxConcurrent) return; const len=alongLength(which); if(len<=0) return; const t=snapAlong(rng(0,len)); const k=Math.floor(rng(0,state.trackCount)); const p=basePoint(which,t); const n=normalOffset(which,k); pushParticle(p.x+n.x,p.y+n.y,false); }
  function spawnOnCorner(which){ if (particles.length >= state.maxConcurrent) return; const L=getFrameLines(); const len=state.cornerSpan; let whichSide, p; if (which==='tl'){ whichSide=(Math.random()<0.5)?'top':'left'; const t=snapAlong(rng(0,len)); p=(whichSide==='top')? {x:L.left+t,y:L.top}:{x:L.left,y:L.top+t}; } else if (which==='tr'){ whichSide=(Math.random()<0.5)?'top':'right'; const t=snapAlong(rng(0,len)); p=(whichSide==='top')? {x:L.right-t,y:L.top}:{x:L.right,y:L.top+t}; } else if (which==='bl'){ whichSide=(Math.random()<0.5)?'bottom':'left'; const t=snapAlong(rng(0,len)); p=(whichSide==='bottom')? {x:L.left+t,y:L.bottom}:{x:L.left,y:L.bottom-t}; } else { whichSide=(Math.random()<0.5)?'bottom':'right'; const t=snapAlong(rng(0,len)); p=(whichSide==='bottom')? {x:L.right-t,y:L.bottom}:{x:L.right,y:L.bottom-t}; } const k=Math.floor(rng(0,state.trackCount)); const n=normalOffset(whichSide,k); pushParticle(p.x+n.x,p.y+n.y,true); }

  function audioRMS(){ if(!analyser) return 0; analyser.getByteTimeDomainData(timebuf); let s=0; for(let i=0;i<timebuf.length;i++){ const v=(timebuf[i]-128)/128; s+=v*v; } return Math.sqrt(s/timebuf.length); }
  function chooseSideBySpectrum(){ if(!analyser || !state.audioSides) { const s=sides[(sideTick++)&3]; return s; } analyser.getByteFrequencyData(freq); const N=freq.length; const sr=audioCtx?audioCtx.sampleRate:44100; const binHz=sr/2/N; const idx=(hz)=>Math.floor(hz/binHz); const band=(lo,hi)=>{ let a=idx(lo), b=idx(hi); a=Math.max(0,a); b=Math.min(N-1,b); let s=0,c=0; for(let i=a;i<=b;i++){ s+=freq[i]; c++; } return s/Math.max(1,c); }; const valTop=band(6000,12000); const valRight=band(2000,4000); const valBottom=band(20,150); const valLeft=band(150,500); let best='top', bestV=valTop; if(valRight>bestV){best='right'; bestV=valRight;} if(valBottom>bestV){best='bottom'; bestV=valBottom;} if(valLeft>bestV){best='left'; bestV=valLeft;} return best; }
  function nextCorner(){ if(!state.equalCorners) return ['tl','tr','bl','br'][(Math.random()*4)|0]; const arr=['tl','tr','bl','br']; return arr[(cornerIdx++)%4]; }

  // ====== メインループ（FPS制御つき） ======
  let tPrev=performance.now(), lastDraw=0, fpsTrack=[];
  function loop(t){
    const targetMS = 1000 / Math.max(1,state.fpsTarget);
    if (t - lastDraw < targetMS) { return requestAnimationFrame(loop); }
    const dt = Math.min(48, t - tPrev); tPrev = t; lastDraw = t;

    // 背景は必要時のみ再描画
    drawBG();
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBGToMain();

    updateToneColor();
    const rms=audioRMS();
    const spawnBudget=Math.max(0, state.density*(1 + rms*state.sensitivity));
    let cornerAttempts=Math.floor(spawnBudget*state.cornerRate*4);
    let sideAttempts=Math.floor(spawnBudget*(1-state.cornerRate)*4);
    while(cornerAttempts-- > 0) spawnOnCorner(nextCorner());
    while(sideAttempts-- > 0) spawnOnSide(chooseSideBySpectrum());

    ctx.globalCompositeOperation = state.blend;
    const out=[]; for(let i=0;i<particles.length;i++){ const p=particles[i]; if(p.t < p.life){ renderParticle(p, dt); out.push(p); } }
    particles = out;
    ctx.globalCompositeOperation = 'source-over';

    fpsTrack.push(1000/Math.max(1,dt)); if (fpsTrack.length>20) fpsTrack.shift();
    const fps=Math.round(fpsTrack.reduce((s,v)=>s+v,0)/fpsTrack.length);
    fpsLabel.textContent='FPS '+(isFinite(fps)?fps:'--');

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
