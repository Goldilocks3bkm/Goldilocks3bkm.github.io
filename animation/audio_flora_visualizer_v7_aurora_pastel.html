<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>Audio Visualizer v6.3.1 – パステル＆オーロラ対応版</title>
  <!-- p5.js only for canvas/draw utils -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
  <style>
    :root { color-scheme: dark; --glass: rgba(255,255,255,0.08); --line: rgba(255,255,255,0.16); }
    html, body { margin:0; padding:0; background:#0b0b0f; color:#eee; font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", "Noto Sans JP", sans-serif; }
    /* Top/desktop panel */
    #ui { position: fixed; left: 16px; top: 16px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; background:var(--glass); border:1px solid var(--line); padding:8px 10px; border-radius:12px; backdrop-filter: blur(6px); z-index: 700; }
    #ui button, #ui label, #ui select, #ui summary { appearance:none; border:1px solid rgba(255,255,255,0.18); background:rgba(255,255,255,0.08); color:#eee; padding:6px 10px; border-radius:10px; cursor:pointer; font-size:12px; }
    #ui select { padding:6px 8px; }
    #ui button:hover, #ui label:hover { background: rgba(255,255,255,0.16); }
    #file { position:absolute; width:0.1px; height:0.1px; opacity:0; overflow:hidden; z-index:-1; }
    #legend { position: fixed; right: 16px; top: 16px; font-size: 12px; line-height: 1.45; color: #cfd7ff; opacity: .9; background: rgba(16,16,24,.35); border: 1px solid rgba(255,255,255,.08); padding: 8px 10px; border-radius: 10px; z-index: 600; max-width: 44ch; }
    /* Mobile */
    #fab { position: fixed; right: 14px; bottom: 14px; z-index: 650; border: 1px solid rgba(255,255,255,0.25); background: rgba(255,255,255,0.15); color:#fff; padding: 12px; border-radius: 999px; cursor: pointer; font-size: 16px; display:none; }
    #backdrop { position: fixed; inset: 0; background: rgba(0,0,0,0.35); z-index: 800; display:none; }
    #panel { position: fixed; left: 0; right: 0; bottom: -70vh; height: 60vh; z-index: 900; background: rgba(20,20,28,0.95); backdrop-filter: blur(10px); border-top: 1px solid rgba(255,255,255,0.14); transition: bottom 0.25s ease; padding: 8px 12px 12px; border-radius: 14px 14px 0 0; touch-action: none; }
    #panel.open { bottom: 0; }
    #panel .handle { display:flex; justify-content:center; padding: 6px 0 10px; }
    #panel .handle .bar { width: 44px; height: 4px; border-radius: 999px; background: rgba(255,255,255,0.35); }
    #panel .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-bottom:8px; }
    #panel .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    #panel h4 { margin: 4px 0 6px; font-size: 13px; opacity: .9; }
    #panel select, #panel button, #panel label { font-size: 14px; padding: 10px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.08); color:#eee; }
    .pill { display:inline-flex; gap:6px; align-items:center; padding:6px 10px; border:1px solid rgba(255,255,255,0.18); border-radius: 999px; background: rgba(255,255,255,0.08); font-size:12px; cursor:pointer; }
    .active { outline: 1px solid rgba(255,255,255,0.45); }
    a { color: #9ec5ff; }

    canvas { position: fixed !important; inset: 0 !important; z-index: 0 !important; pointer-events: none !important; }
    #edgeOpen { position: fixed; left:0; right:0; bottom:0; height:28px; z-index:640; background: transparent; display:none; }
    @media (max-width: 680px) { #ui{display:none;} #legend{display:none;} #fab{display:block;} #edgeOpen{display:block;} }
    /* === モバイルで説明欄(#legend)を非表示（横画面も含む）=== */
    @media (hover: none) and (pointer: coarse) and (max-width: 820px) { #legend { display: none !important; } }
    @media (hover: none) and (pointer: coarse) and (max-height: 520px) { #legend { display: none !important; } }
  </style>
</head>
<body>
  <!-- Desktop/Tablet controls -->
  <div id="ui">
    <label for="file">音声ファイル</label><input id="file" type="file" accept="audio/*"/>
    <button id="mic">マイク</button>
    <button id="play">再生</button>
    <button id="pause">一時停止</button>
    <button id="record">録画開始</button>
    <details id="adv"><summary>⚙️ 調整</summary>
      <div class="row">
        <label>音量感度</label>
        <select id="sense">
          <option value="low">鈍感</option>
          <option value="normal" selected>ふつう</option>
          <option value="high">敏感</option>
          <option value="ultra">超敏感(スマホ)</option>
        </select>
        <label>画面ON</label><button id="wake">OFF</button>
      </div>
      <div class="row">
        <label>双葉/花 量</label>
        <select id="plantAmt">
          <option value="0.6">少なめ</option>
          <option value="1" selected>ふつう</option>
          <option value="1.6">多め</option>
        </select>
        <label>🦋 量</label>
        <select id="bflyAmt">
          <option value="0.3" selected>控えめ</option>
          <option value="1">ふつう</option>
          <option value="1.6">多め</option>
        </select>
      </div>
      <div class="row">
        <label>☄️ 流星 量</label>
        <select id="meteorAmt">
          <option value="0.6" selected>少なめ</option>
          <option value="1">ふつう</option>
          <option value="1.6">多め</option>
        </select>
        <label>✨ 星 量</label>
        <select id="dustAmt">
          <option value="0.6">少なめ</option>
          <option value="1" selected>ふつう</option>
          <option value="1.6">多め</option>
        </select>
      </div>
    </details>
    <span id="status" style="margin-left:8px; font-size:12px; opacity:.85;">準備中</span>
  </div>

  <!-- Mobile drawer -->
  <div id="backdrop"></div>
  <button id="fab">⚙️</button>
  <div id="edgeOpen" aria-hidden="true"></div>
  <div id="panel" aria-modal="true" role="dialog">
    <div class="handle" id="handle"><div class="bar"></div></div>
    <div class="row" style="justify-content:space-between">
      <label class="pill" id="pickFileM" for="file"><span>📄</span><span>音声</span></label>
      <div class="pill" id="micM"><span>🎤</span><span>マイク</span></div>
      <div class="pill" id="playM"><span>▶</span><span>再生</span></div>
      <div class="pill" id="pauseM"><span>⏸</span><span>停止</span></div>
      <div class="pill" id="recM"><span>⏺</span><span>録画</span></div>
      <div class="pill" id="closeM"><span>⬇</span><span>閉じる</span></div>
    </div>
    <h4>音量感度</h4>
    <div class="row">
      <select id="senseM">
        <option value="low">鈍感</option>
        <option value="normal" selected>ふつう</option>
        <option value="high">敏感</option>
        <option value="ultra">超敏感(スマホ)</option>
      </select>
      <label>画面ON</label><button id="wakeM">OFF</button>
    </div>
    <h4>量の調整</h4>
    <div class="grid">
      <div><label>双葉/花</label>
        <select id="plantAmtM">
          <option value="0.6">少</option><option value="1" selected>普</option><option value="1.6">多</option>
        </select>
      </div>
      <div><label>🦋</label>
        <select id="bflyAmtM">
          <option value="0.3" selected>控</option><option value="1">普</option><option value="1.6">多</option>
        </select>
      </div>
      <div><label>☄️</label>
        <select id="meteorAmtM">
          <option value="0.6" selected>少</option><option value="1">普</option><option value="1.6">多</option>
        </select>
      </div>
      <div><label>✨</label>
        <select id="dustAmtM">
          <option value="0.6">少</option><option value="1" selected>普</option><option value="1.6">多</option>
        </select>
      </div>
    </div>
  </div>

  <div id="legend">
    <div>— 白い線: 基準</div>
    <div>🌱 双葉・🌼 花: 200–2000Hz（<b>同一地点は最大3本</b>）<br>※ 双葉は<b>薄い緑</b>、花は<b>パステル青/ピンク/黄</b></div>
    <div>🦋 ちょうちょ: <b>2000Hz以上</b>（小さく少なめ）</div>
    <div>✨ 星キラキラ: 風景ノイズ（<b>パステル色</b>）</div>
    <div>🌌 オーロラ: <b>長い持続音</b>（低いスペクトル雑然度）で出現</div>
    <div>無音/終了 → 白線のみ</div>
  </div>

  <script>
    // ======= Web Audio (Safari安定) =======
    let audioCtx, analyser, freqData, timeData, sampleRate=44100;
    let mediaEl=null, mediaElSrc=null; // <audio> とその SourceNode
    let micStream=null, micSource=null; // mic
    let destNode=null, mediaRec=null, chunks=[]; // recording
    let usingMic=false, fileLoaded=false, pendingPlay=false;

    const sense = { mode:'normal', ampScale:1.0, gate:0.008, peak:0.12, donDelta:0.08, ampSmooth:0.08 };
    function applySense(mode){
      sense.mode = mode;
      if (mode==='low'){ sense.ampScale=0.85; sense.gate=0.012; sense.peak=0.16; sense.donDelta=0.11; sense.ampSmooth=0.12; }
      else if (mode==='high'){ sense.ampScale=1.2; sense.gate=0.005; sense.peak=0.09; sense.donDelta=0.06; sense.ampSmooth=0.06; }
      else if (mode==='ultra'){ sense.ampScale=2.0; sense.gate=0.0025; sense.peak=0.075; sense.donDelta=0.035; sense.ampSmooth=0.03; }
      else { sense.ampScale=1.0; sense.gate=0.008; sense.peak=0.12; sense.donDelta=0.08; sense.ampSmooth=0.08; }
      const s = document.getElementById('status'); if (s) s.textContent = '感度: ' + mode;
    }

    // ======= Palette helpers (pastel) =======
    const PASTEL_FLOWER = [
      [163,198,255], // blue
      [255,182,193], // pink
      [255,248,180]  // yellow
    ];
    const PASTEL_STAR = PASTEL_FLOWER; // 星も同じパレット
    const LIGHT_LEAF = [190,255,210];  // 薄い緑
    function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
    function mix(c1, c2, t){ return [Math.round(c1[0]*(1-t)+c2[0]*t), Math.round(c1[1]*(1-t)+c2[1]*t), Math.round(c1[2]*(1-t)+c2[2]*t)]; }

    async function ensureAudio(){
      if (!audioCtx){
        const AC = window.AudioContext || window.webkitAudioContext; audioCtx = new AC();
        analyser = audioCtx.createAnalyser(); analyser.fftSize = 2048; analyser.smoothingTimeConstant = 0.85;
        freqData = new Uint8Array(analyser.frequencyBinCount);
        timeData = new Uint8Array(analyser.fftSize);
        if (!mediaEl){ mediaEl = new Audio(); mediaEl.preload='auto'; mediaEl.crossOrigin='anonymous'; mediaEl.addEventListener('loadedmetadata', ()=>{ try{ sampleRate = mediaEl.mozSampleRate || mediaEl.webkitAudioDecodedByteCount || audioCtx.sampleRate; }catch(_){} }); }
      }
    }

    function connectNode(node, monitor){
      try{ node.disconnect(); }catch(_){ }
      node.connect(analyser);
      if (monitor) node.connect(audioCtx.destination);
    }

    async function useFile(file){
      await ensureAudio(); usingMic=false; fileLoaded=false;
      if (!mediaElSrc){ mediaElSrc = audioCtx.createMediaElementSource(mediaEl); }
      connectNode(mediaElSrc, true);
      const url = URL.createObjectURL(file);
      mediaEl.src = url; mediaEl.load();
      mediaEl.oncanplay = ()=>{ fileLoaded=true; const s=document.getElementById('status'); if (s) s.textContent='読み込み完了'; if(pendingPlay){ playFile(); pendingPlay=false; } };
      mediaEl.onended = ()=>{ lastActiveMillis = millis()-5000; };
    }

    async function playFile(){
      if (!fileLoaded) { pendingPlay=true; const s=document.getElementById('status'); if(s) s.textContent='読み込み中… → 自動再生'; return; }
      try{ await audioCtx.resume(); }catch(_){ }
      try{ await mediaEl.play(); const s=document.getElementById('status'); if(s) s.textContent='再生中'; }catch(e){ const s=document.getElementById('status'); if(s) s.textContent='再生ブロック: 画面をタップ後にもう一度'; }
    }

    async function pauseFile(){ try{ mediaEl && mediaEl.pause(); const s=document.getElementById('status'); if(s) s.textContent='一時停止'; }catch(_){ } }

    async function useMic(){
      await ensureAudio(); usingMic=true; fileLoaded=false; try{ mediaEl && mediaEl.pause(); }catch(_){}
      const stream = await navigator.mediaDevices.getUserMedia({audio:true}); micStream = stream; if (!micSource){ micSource = audioCtx.createMediaStreamSource(stream); }
      connectNode(micSource, false); const s=document.getElementById('status'); if(s) s.textContent='マイク入力中';
    }

    // ======= Analysis helpers =======
    function energyHz(low, high){
      const nyq = audioCtx.sampleRate/2; const binHz = nyq / freqData.length;
      let i0 = Math.max(0, Math.floor(low / binHz)); let i1 = Math.min(freqData.length-1, Math.ceil(high / binHz));
      if (i1 <= i0) return 0; let sum=0; for (let i=i0;i<=i1;i++) sum += freqData[i]; return sum / (i1-i0+1);
    }
    function rmsLevel(){ // 0..1
      analyser.getByteTimeDomainData(timeData); let sum=0; for (let i=0;i<timeData.length;i++){ const v=(timeData[i]-128)/128; sum += v*v; } return Math.sqrt(sum/timeData.length);
    }

    // ======= Visual State & Drawing =======
    const plants=[], butterflies=[], dustStars=[], meteors=[], auroras=[];
    let baselineY, prevLevel=0, donCooldown=0, lastActiveMillis=0, silenceFade=0, toneHold=0;
    let NUM_BINS=36, BIN_W=0;
    const E = { level:0, plantBand:0, bflyBand:0, bass:0, ultra:0, entropy:0 };
    const amount = { plant:1, bfly:0.33, meteor:0.6, dust:1 };
    const TH = { plant: ()=> sense.mode==='ultra'? 55 : 70, bfly: ()=> sense.mode==='ultra'? 110 : 130 };

    function calcBins(){ NUM_BINS = Math.max(24, Math.floor(width/48)); BIN_W = width/NUM_BINS; }
    function xToBin(x){ return Math.max(0, Math.min(NUM_BINS-1, Math.floor(x/BIN_W))); }
    function countPlantsInBin(bi){ let c=0; for (let p of plants){ if(!p.dead && xToBin(p.x)===bi) c++; } return c; }

    function setup(){ createCanvas(window.innerWidth, window.innerHeight); pixelDensity(window.devicePixelRatio||1); baselineY = height*0.85; calcBins(); bindUI(); bindDrawer(); applySense('normal'); }
    function windowResized(){ resizeCanvas(window.innerWidth, window.innerHeight); baselineY = height*0.85; calcBins(); }

    function bindUI(){
      const $=id=>document.getElementById(id); const status=$('status');
      $('file').addEventListener('change', async (e)=>{ const f=e.target.files[0]; if(!f) return; await useFile(f); });
      $('mic').addEventListener('click', async ()=>{ await useMic(); });
      $('play').addEventListener('click', async ()=>{ await playFile(); });
      $('pause').addEventListener('click', ()=>{ pauseFile(); });
      $('record').addEventListener('click', async ()=>{ if(!mediaRec){ await startRecording(); $('record').textContent='録画停止'; $('record').classList.add('active'); } else { await stopRecording(); $('record').textContent='録画開始'; $('record').classList.remove('active'); }});
      $('sense').addEventListener('change', e=>applySense(e.target.value));
      $('plantAmt').addEventListener('change', e=>amount.plant=parseFloat(e.target.value));
      $('bflyAmt').addEventListener('change', e=>amount.bfly=parseFloat(e.target.value));
      $('meteorAmt').addEventListener('change', e=>amount.meteor=parseFloat(e.target.value));
      $('dustAmt').addEventListener('change', e=>amount.dust=parseFloat(e.target.value));
      $('wake').addEventListener('click', ()=>toggleWake($('wake')));
    }

    function bindDrawer(){
      const $=id=>document.getElementById(id); const panel=$('panel'), fab=$('fab'), backdrop=$('backdrop'), handle=$('handle'), edge=$('edgeOpen');
      const openPanel=(open)=>{ panel.classList.toggle('open', open); backdrop.style.display=open?'block':'none'; document.body.style.overflow=open?'hidden':''; };
      fab.addEventListener('click', ()=>openPanel(true)); $('closeM').addEventListener('click', ()=>openPanel(false)); backdrop.addEventListener('click', ()=>openPanel(false)); edge.addEventListener('click', ()=>openPanel(true)); edge.addEventListener('touchstart', ()=>openPanel(true), {passive:true});
      let startY=null, lastY=null; const onStart=(e)=>{ startY=(e.touches?e.touches[0].clientY:e.clientY); lastY=startY; }; const onMove=(e)=>{ if(startY==null)return; const y=(e.touches?e.touches[0].clientY:e.clientY); lastY=y; const dy=y-startY; if(dy>0){ panel.style.bottom=Math.min(dy, window.innerHeight*0.6)*-1+'px'; } }; const onEnd=()=>{ if(startY==null)return; const dy=lastY-startY; panel.style.bottom=''; if(dy>60) openPanel(false); startY=null; lastY=null; };
      panel.addEventListener('touchstart', onStart, {passive:true}); panel.addEventListener('touchmove', onMove, {passive:true}); panel.addEventListener('touchend', onEnd); handle.addEventListener('mousedown', onStart); window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onEnd); window.addEventListener('keydown', (e)=>{ if(e.key==='Escape'&&panel.classList.contains('open')) openPanel(false); });
      const mapSel=(m,d)=>{ $(m).addEventListener('change', e=>{ $(d).value=e.target.value; $(d).dispatchEvent(new Event('change')); }); };
      $('micM').addEventListener('click', ()=>document.getElementById('mic').click()); $('playM').addEventListener('click', ()=>document.getElementById('play').click()); $('pauseM').addEventListener('click', ()=>document.getElementById('pause').click()); $('recM').addEventListener('click', ()=>document.getElementById('record').click());
      mapSel('senseM','sense'); mapSel('plantAmtM','plantAmt'); mapSel('bflyAmtM','bflyAmt'); mapSel('meteorAmtM','meteorAmt'); mapSel('dustAmtM','dustAmt'); $('wakeM').addEventListener('click', ()=>toggleWake($('wakeM')));
    }

    // Wake Lock
    let wakeLock=null; async function toggleWake(btn){ try{ if(!wakeLock){ wakeLock=await navigator.wakeLock.request('screen'); btn.textContent='ON'; } else { await wakeLock.release(); wakeLock=null; btn.textContent='OFF'; } }catch(e){ btn.textContent='NG'; } }

    // Recording (canvas+audio)
    async function startRecording(){ await ensureAudio(); const canvasStream=document.querySelector('canvas').captureStream(60); if(!destNode){ destNode=audioCtx.createMediaStreamDestination(); }
      // route current source to recorder
      if (usingMic && micSource){ micSource.connect(destNode); }
      if (!usingMic && mediaElSrc){ mediaElSrc.connect(destNode); }
      const mix = new MediaStream([ ...canvasStream.getVideoTracks(), ...destNode.stream.getAudioTracks() ]);
      mediaRec = new MediaRecorder(mix, { mimeType:'video/webm;codecs=vp9,opus' }); chunks=[]; mediaRec.ondataavailable=e=>{ if(e.data.size>0) chunks.push(e.data); }; mediaRec.onstop=()=>{ const blob=new Blob(chunks,{type:'video/webm'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='visualizer_v6_3_pastel_aurora.webm'; a.click(); setTimeout(()=>URL.revokeObjectURL(url), 1000); mediaRec=null; };
      mediaRec.start(); }
    async function stopRecording(){ if(mediaRec && mediaRec.state!=='inactive') mediaRec.stop(); }

    // Easing
    function easeOutCubic(t){ return 1-Math.pow(1-t,3); } function easeOutBack(t){ const c1=1.70158, c3=c1+1; return 1 + c3*Math.pow(t-1,3) + c1*Math.pow(t-1,2); }

    class Plant{
      constructor(x,type,energy){
        this.x=x; this.type=type; this.life=0; this.dead=false;
        const baseH=(type==='sprout')? random(10,18): random(22,44);
        const sizeK=map(energy,55,255,0.9,1.4,true);
        this.hTarget=baseH*sizeK; this.growFrames=Math.floor(random(48,90));
        this.bloomStart=this.growFrames*0.55; this.age=0; this.maxAge=this.growFrames+Math.floor(random(90,160));
        this.leafW=random(10,16)*sizeK*(type==='sprout'?1.2:1.0); this.leafH=random(5.5,8.0)*sizeK*(type==='sprout'?1.2:1.0);
        this.flowerR=random(7,12)*sizeK; this.swing=random(0.012,0.022); this.seed=random(1000);
        if (type==='flower'){ this.col = pick(PASTEL_FLOWER); this.colCenter = mix(this.col, [255,255,255], 0.25); }
        else { this.leafCol = LIGHT_LEAF; }
      }
      update(){ this.age++; if(this.age>this.maxAge) this.dead=true; }
      draw(silence){
        const y0=height*0.85;
        const t=Math.max(0,Math.min(1,this.age/this.growFrames)); const grow=easeOutCubic(t);
        const sway=Math.sin(frameCount*this.swing+this.seed)*5*(1-silence); const stemH=this.hTarget*grow*(1-silence*0.95);
        const topX=this.x+sway, topY=y0-stemH;
        // stem
        stroke(255); strokeWeight(1.8); line(this.x,y0,topX,topY); noStroke();
        if(this.type==='flower'){
          const bt=t<0.001?0:Math.max(0,Math.min(1,(this.age-this.bloomStart)/(this.growFrames-this.bloomStart+1))); const open=easeOutBack(bt);
          const r=this.flowerR*(0.4+0.6*open)*(1-silence*0.9);
          const a=235*(1-silence);
          push(); translate(topX,topY);
          fill(this.col[0], this.col[1], this.col[2], a);
          for(let i=0;i<6;i++){ const a0=i*PI/3+this.seed*0.2; const pr=r*0.95; ellipse(Math.cos(a0)*pr, Math.sin(a0)*pr, pr*0.95, pr*0.95); }
          fill(this.colCenter[0], this.colCenter[1], this.colCenter[2], a);
          circle(0,0,r*0.9);
          pop();
        } else {
          const lr=easeOutBack(t);
          const lw=this.leafW*lr*(1-silence*0.9), lh=this.leafH*lr*(1-silence*0.9);
          const a=230*(1-silence);
          push(); translate(topX,topY);
          fill(this.leafCol[0], this.leafCol[1], this.leafCol[2], a);
          ellipse(-lw*0.7,0,lw,lh); ellipse(lw*0.7,0,lw,lh);
          pop();
        }
      }
    }

    class Butterfly{
      constructor(x,y,s=0.45){ this.x=x; this.y=y; this.life=0; this.maxLife=300+random(120); this.dead=false; this.vx=random(-0.5,0.5); this.vy=random(-0.25,0.25); this.phase=random(TWO_PI); this.s=s*random(0.9,1.1);}
      update(){ this.life++; this.phase+=0.05; this.x+=this.vx+Math.sin(this.phase*1.6)*0.6; this.y+=this.vy+Math.cos(this.phase*1.1)*0.45; this.x=Math.max(-20,Math.min(width+20,this.x)); this.y=Math.max(height*0.25,Math.min(height*0.85-12,this.y)); if(this.life>this.maxLife) this.dead=true; }
      draw(silence){ const a=(1-silence)*220*(1-this.life/this.maxLife); push(); translate(this.x,this.y); scale(this.s); noStroke(); fill(255,a); const flap=0.9+Math.sin(frameCount*0.45)*0.30*(1-silence); push(); scale(flap,1); ellipse(-9,-2,16,12); ellipse(-8,5,14,10); ellipse(9,-2,16,12); ellipse(8,5,14,10); pop(); rectMode(CENTER); rect(0,0,2.2,12,2); stroke(255,a); strokeWeight(1); noFill(); bezier(-1,-6,-5,-10,-7,-12,-8,-13); bezier(1,-6,5,-10,7,-12,8,-13); pop(); }
    }

    class DustStar{
      constructor(x,y,noiseIdx){ this.x=x; this.y=y; this.life=0; this.maxLife=random(80,180); this.size=map(noiseIdx,0.6,1.0,0.9,2.8,true)*random(0.8,1.4); this.alpha=random(90,180); this.dead=false; this.col = pick(PASTEL_STAR); }
      update(){ this.life++; if(this.life>this.maxLife) this.dead=true; }
      draw(silence){ const a=this.alpha*(1-silence); fill(this.col[0], this.col[1], this.col[2], a); noStroke(); circle(this.x,this.y,this.size); }
    }

    class Meteor{
      constructor(x,y,vx,vy,life){ this.x=x; this.y=y; this.vx=vx; this.vy=vy; this.life=0; this.maxLife=life; this.dead=false; this.trail=[]; }
      update(){ this.life++; this.trail.push({x:this.x,y:this.y}); if(this.trail.length>20) this.trail.shift(); this.x+=this.vx; this.y+=this.vy; if(this.life>this.maxLife) this.dead=true; }
      draw(silence){ const alpha=230*(1-silence); noFill(); for (let i=0;i<this.trail.length-1;i++){ const p1=this.trail[i],p2=this.trail[i+1]; const a=alpha*(i/this.trail.length); stroke(255,a); strokeWeight(map(i,0,this.trail.length-1,1,3.2)); line(p1.x,p1.y,p2.x,p2.y); } noStroke(); fill(255,alpha); ellipse(this.x,this.y,4.5,4.5); }
    }

    // New: Aurora (for sustained tones)
    class Aurora{
      constructor(){
        this.life=0; this.maxLife=Math.floor(random(260,420));
        this.y0=random(height*0.10, height*0.35);
        this.amp=random(18,32); this.speed=random(0.0020,0.0045);
        this.noiseSeed=random(1000); this.col=pick(PASTEL_FLOWER);
      }
      update(){ this.life++; this.noiseSeed+=0.0015; if(this.life>this.maxLife) this.dead=true; }
      draw(silence){
        const baseAlpha=150*(1-silence)*(1-this.life/this.maxLife);
        noFill();
        for(let layer=0; layer<6; layer++){
          const a = baseAlpha * (0.6 - layer*0.08);
          if (a<=2) continue;
          stroke(this.col[0], this.col[1], this.col[2], a);
          strokeWeight(5 - layer*0.5);
          beginShape();
          for(let x=0; x<=width; x+=14){
            const n = noise(this.noiseSeed + x*this.speed, frameCount*0.01 + layer*0.2);
            const y = this.y0 + (n-0.5)*2*this.amp + (layer-2.5)*4;
            vertex(x, y);
          }
          endShape();
        }
      }
    }

    function draw(){
      background(11,11,15,255);
      // Baseline
      stroke(255); strokeWeight(3); line(0, height*0.85, width, height*0.85); noStroke();

      if (!analyser){ return; }
      analyser.getByteFrequencyData(freqData);
      const level = rmsLevel() * sense.ampScale; const lvl = Math.min(Math.max(level,0),1);
      const active = lvl > sense.gate || (!usingMic && mediaEl && !mediaEl.paused);
      if (active) lastActiveMillis = millis(); const silentFor = millis()-lastActiveMillis; silenceFade = (silentFor>900) ? Math.min(1, silenceFade+0.03) : Math.max(0, silenceFade-0.05);

      const plantBand = energyHz(200,2000); const bflyBand = energyHz(2000,8000); const bass = energyHz(20,120); const ultra = energyHz(8000,16000);
      let sum=0; for(let i=0;i<freqData.length;i++) sum += (freqData[i]+1e-6); let ent=0; for(let i=0;i<freqData.length;i++){ const p=(freqData[i]+1e-6)/sum; ent += -p*Math.log(p); } ent = ent / Math.log(freqData.length);
      E.level = lerp(E.level, lvl, 0.2); E.plantBand=lerp(E.plantBand, plantBand, 0.25); E.bflyBand=lerp(E.bflyBand, bflyBand, 0.25); E.bass=lerp(E.bass, bass, 0.25); E.ultra=lerp(E.ultra, ultra, 0.25); E.entropy=lerp(E.entropy, ent, 0.25);

      // Dust (pastel)
      const dustCount = Math.floor(map(E.entropy, 0.6, 1.0, 0, 10*amount.dust, true)); for(let i=0;i<dustCount;i++) dustStars.push(new DustStar(random(width), random(height*0.05, height*0.65), E.entropy));

      // DON!
      const delta = Math.max(0, lvl - prevLevel); prevLevel = lvl; if (delta > sense.donDelta && lvl > sense.gate*2){ donCooldown=22; const clusters=Math.floor(random(1, 3+amount.plant)); for(let c=0;c<clusters;c++){ const center=random(width); const n=Math.floor(random(3,6)*amount.plant); for(let i=0;i<n;i++){ const x=Math.min(Math.max(center+random(-24,24),0),width); spawnPlantSmart(E.plantBand, x); } } }
      if (donCooldown>0) donCooldown--;

      // Plants
      if (E.plantBand > TH.plant() && random() < 0.35*amount.plant) spawnPlantSmart(E.plantBand);
      if (delta > (sense.donDelta*0.6)) { const burst=Math.floor(random(2,5)*amount.plant); for(let i=0;i<burst;i++) spawnPlantSmart(E.plantBand); }

      // Butterflies
      const bflyProbBase = (sense.mode==='ultra'? 0.016 : 0.012); const idleProb = (sense.mode==='ultra'? 0.005 : 0.003);
      if ((E.bflyBand > TH.bfly() && random() < bflyProbBase * amount.bfly) || random() < idleProb * amount.bfly) { butterflies.push(new Butterfly(random(width), random(height*0.35, height*0.75), 0.45)); }

      // Tone hold for Aurora (sustained & tonal => low entropy)
      const toneNow = ((E.entropy < 0.48 && E.level > sense.gate*2) || (E.ultra > 140 && E.entropy < 0.55));
      toneHold = toneNow ? Math.min(999, toneHold+1) : Math.max(0, toneHold-2);
      if (toneHold > 42 && auroras.length < 3){ auroras.push(new Aurora()); toneHold = 0; }

      // Meteors (suppress while aurora-building)
      const meteorTrig = (E.level > 0.2) || (E.bass > 130) || (E.ultra > 130);
      if (toneHold < 18 && auroras.length === 0 && donCooldown===0 && meteorTrig && meteors.length < 6 && random() < 0.22 * amount.meteor) {
        const dir = random([-1,1]);
        const startX = (dir>0 ? random(width*0.05, width*0.45) : random(width*0.55, width*0.95));
        const startY = random(height*0.05, height*0.5);
        const vx = dir * random(7.5, 10.5); const vy = random(6.0, 9.0);
        meteors.push(new Meteor(startX,startY,vx,vy, Math.floor(random(28,50))));
      }

      // Draw/update all
      for (let i=auroras.length-1; i>=0; i--){ auroras[i].update(); auroras[i].draw(silenceFade); if(auroras[i].dead) auroras.splice(i,1); }
      for (let i=dustStars.length-1;i>=0;i--){ dustStars[i].update(); dustStars[i].draw(silenceFade); if(dustStars[i].dead) dustStars.splice(i,1); }
      for (let i=meteors.length-1;i>=0;i--){ meteors[i].update(); meteors[i].draw(silenceFade); if(meteors[i].dead) meteors.splice(i,1); }
      for (let i=plants.length-1;i>=0;i--){ plants[i].update(); plants[i].draw(silenceFade); if(plants[i].dead) plants.splice(i,1); }
      for (let i=butterflies.length-1;i>=0;i--){ butterflies[i].update(); butterflies[i].draw(silenceFade); if(butterflies[i].dead) butterflies.splice(i,1); }
    }

    function spawnPlantSmart(energy, fixedX=null){ const tries=12; for(let k=0;k<tries;k++){ const x=(fixedX==null)? random(width): fixedX+random(-6,6); const bi=xToBin(x); if(countPlantsInBin(bi)<3){ const type=(random()<0.55?'sprout':'flower'); plants.push(new Plant(Math.min(Math.max(x,0),width), type, energy)); break; } } }
  </script>
</body>
</html>